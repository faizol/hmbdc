#include "hmbdc/time/Time.hpp"
#include "hmbdc/app/Config.hpp"
#include <iostream>
#include <fstream>
#include <sstream>

/**
 * @brief a bag is a file that contains a sequence of timestamped TIPS messages
 * It is normally generated by the tips console tool, and it can be played back to a domain
 * via the tips console tool.
 * It is also possible to write customized tools to consume and record bags using 
 * the OutputBag and InputBag classes below
 * Check out its usage in tips console source code
 * 
 */
namespace hmbdc { namespace tips {
/**
 * @brief presented at the beginning of a bag 
 * Following the BagHead there is a json text for the config to describe the bag
 * 
 */
struct BagHead {
    time::SysTime createdTs;
    size_t cfgLen{0};

    friend
    std::ostream& operator << (std::ostream& os, BagHead const& h) {
        return os.write((char const*)&h, sizeof(h));
    }
    friend
    std::istream& operator >> (std::istream& is, BagHead& h) {
        return is.read((char*)&h, sizeof(h));
    }
};

/**
 * @brief presented at the beginning of a message record in a bag
 * 
 */
struct BagMessageHead {
    time::SysTime createdTs;
    size_t attLen{0};
    uint16_t tag{0};
    uint16_t reserved{0};
    uint32_t reserved2{0};

    friend
    std::ostream& operator << (std::ostream& os, BagMessageHead const& h) {
        return os.write((char const*)&h, sizeof(h));
    }
    friend
    std::istream& operator >> (std::istream& is, BagMessageHead& h) {
        return is.read((char*)&h, sizeof(h));
    }
};

/**
 * @brief a bag for output / record purpose
 * 
 */
struct OutputBag {
    /**
     * @brief Construct a new Output Bag object
     * 
     * @param file path to the output file
     * @param config the config (contains bufWidth) used to generate the bag
     */
    OutputBag(char const* file, app::Config const& config)
    : bufWidth_(config.getExt<size_t>("bufWidth"))
    , recordBag_(file, std::ofstream::out | std::ios::binary) {
        std::ostringstream oss; 
        boost::property_tree::write_json(oss, config);
        auto cfgText = oss.str();
        size_t l = cfgText.size();
        BagHead bh{time::SysTime::now(), l};
        recordBag_ << bh;
        recordBag_.write(cfgText.c_str(), cfgText.size());
    }

    /**
     * @brief the bufWidth
     * 
     * @return size_t 
     */
    size_t bufWidth() const {
        return bufWidth_;
    }

    /**
     * @brief record a message into the bag
     * 
     * @param tag message tag
     * @param bytes message bytes - the buffer should be matching bufWidth in Config
     * @param att attachment 
     */
    void record(uint16_t tag, uint8_t const* bytes, app::hasMemoryAttachment* att) {
        BagMessageHead bh{time::SysTime::now(), att?att->len:0xfffffffffffffffful, tag};
        recordBag_ << bh;
        recordBag_.write((char const*)bytes, bufWidth_);
        if (att) {
            recordBag_.write((char*)att->attachment, att->len);
        }
    }

    /**
     * @brief check the status of the bag
     * 
     * @return true - everything is fine can record more
     * @return false - not valid bag object
     */
    operator bool() const {
        return (bool)recordBag_;
    }

    /**
     * @brief close the bag file
     * 
     */
    void close() {
        recordBag_.close();
    }

private:
    size_t bufWidth_;
    std::ofstream recordBag_;
};

/**
 * @brief A read / playable bag
 * 
 */
struct InputBag {
    /**
     * @brief Construct a new Input Bag object
     * 
     * @param file the bag file
     */
    InputBag(char const* file)
    : playBag_(file, std::ofstream::in | std::ios::binary) {
        playBag_ >> bh_;
        std::ostringstream oss;
        char conf[bh_.cfgLen + 1];
        playBag_.read(conf, bh_.cfgLen);
        conf[bh_.cfgLen] = 0;
        config_ = app::Config(conf);
        bufWidth_ = config_.getExt<size_t>("bufWidth");
    }

    /**
     * @brief get the Bag Head
     * 
     * @return BagHead const& 
     */
    BagHead const& bagHead() const {
        return bh_;
    }

    /**
     * @brief get the config of this bag
     * 
     * @return app::Config const&
     */
    app::Config const& config() const {
        return config_;
    }

    /**
     * @brief the bufWidth
     * 
     * @return size_t 
     */
    size_t bufWidth() const {
        return bufWidth_;
    }

    /**
     * @brief bag object status
     * 
     * @return true - can play more
     * @return false 
     */
    operator bool() const {
        return (bool)playBag_;
    }

    /**
     * @brief check end of bag reached
     * 
     * @return true 
     * @return false 
     */
    bool eof() const {
        return playBag_.eof();
    }

    /**
     * @brief play a message into user provided buffer
     * 
     * @param tag output tag
     * @param bytes message bytes - its size >= bufWidth
     * @param att the attachment coming with the message, attachment memory is not allocated 
     * by the user. Its is allocated by this func
     * @return BagMessageHead - it also contains the tag and other info
     */
    BagMessageHead play(uint16_t& tag, uint8_t* bytes, app::hasMemoryAttachment*& att) {
        BagMessageHead bmh;
        playBag_ >> bmh;
        if (playBag_) {
            tag = bmh.tag;
            playBag_.read((char*)bytes, bufWidth_);
            if (bmh.attLen != 0xfffffffffffffffful) {
                att = new (bytes) app::hasMemoryAttachment;
                att->len = bmh.attLen;
                att->attachment = malloc(sizeof(size_t) + att->len);
                auto& refCount = *(size_t*)att->attachment;
                refCount = 1;
                att->clientData[0] = (uint64_t)&refCount;
                att->attachment = (char*)att->attachment + sizeof(size_t);
                att->afterConsumedCleanupFunc = [](app::hasMemoryAttachment* att) {
                    auto& refCount = *((size_t*)att->clientData[0]);
                    if (0 == __atomic_sub_fetch(&refCount, 1, __ATOMIC_RELAXED)) {
                        auto toFree = (char*)att->attachment;
                        toFree -= sizeof(size_t);
                        ::free(toFree);
                    }
                };

                if (!playBag_.read((char*)att->attachment, att->len)) {
                    att->release();
                    playBag_.close();
                }
            } else {
                att = nullptr;
            }
        }
        return bmh;
    }

    /**
     * @brief close the file
     * 
     */
    void close() {
        playBag_.close();
    }

private:
    BagHead bh_; 
    size_t bufWidth_{0};
    std::ifstream playBag_;
    app::Config config_;
};

}}
