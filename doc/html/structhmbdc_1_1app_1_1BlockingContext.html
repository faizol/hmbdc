<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hmbdc: hmbdc::app::BlockingContext&lt; MessageTuples &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hmbdc
   </div>
   <div id="projectbrief">simplify-high-performance-messaging-programming</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehmbdc.html">hmbdc</a></li><li class="navelem"><a class="el" href="namespacehmbdc_1_1app.html">app</a></li><li class="navelem"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">BlockingContext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="structhmbdc_1_1app_1_1BlockingContext-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hmbdc::app::BlockingContext&lt; MessageTuples &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html" title="A BlockingContext is like a media object that facilitates the communications for the Clients that it ...">BlockingContext</a> is like a media object that facilitates the communications for the Clients that it is holding. Each <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is powered by a single OS thread. a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> needs to be started once and only once to a single <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html" title="A BlockingContext is like a media object that facilitates the communications for the Clients that it ...">BlockingContext</a> before any messages sending happens - typically in the initialization stage in main(), undefined behavior otherwise.  
 <a href="structhmbdc_1_1app_1_1BlockingContext.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BlockingContext_8hpp_source.html">BlockingContext.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext_1_1can__handle.html">can_handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext_1_1createEntry.html">createEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext_1_1deliverAll.html">deliverAll</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext_1_1MCGen.html">MCGen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext_1_1MCGen_3_01std_1_1tuple_3_01Messages_01_8_8_8_01_4_01_4.html">MCGen&lt; std::tuple&lt; Messages ... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext_1_1setupConduit.html">setupConduit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext_1_1setupConduit_3_01MsgConduits_00_01DeliverPred_00_01std_c530c38418fd296882d5c4662ea1f268.html">setupConduit&lt; MsgConduits, DeliverPred, std::tuple&lt; M, Messages... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext_1_1TransportEntries.html">TransportEntries</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a533f7c6ae7c037ecad6a56a0a5f8fc5e"><td class="memItemLeft" align="right" valign="top"><a id="a533f7c6ae7c037ecad6a56a0a5f8fc5e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a533f7c6ae7c037ecad6a56a0a5f8fc5e">BlockingContext</a> ()</td></tr>
<tr class="memdesc:a533f7c6ae7c037ecad6a56a0a5f8fc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">trivial ctor <br /></td></tr>
<tr class="separator:a533f7c6ae7c037ecad6a56a0a5f8fc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916bbfb779c60dfca6fe6237182ec566"><td class="memTemplParams" colspan="2">template&lt;typename Client , typename DeliverPred  = deliverAll&gt; </td></tr>
<tr class="memitem:a916bbfb779c60dfca6fe6237182ec566"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a916bbfb779c60dfca6fe6237182ec566">start</a> (<a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;c, size_t capacity=1024, size_t maxItemSize=<a class="el" href="structhmbdc_1_1max__size__in__tuple.html">max_size_in_tuple</a>&lt; typename Client::Interests &gt;::value, uint64_t cpuAffinity=0, <a class="el" href="structhmbdc_1_1time_1_1Duration.html">time::Duration</a> maxBlockingTime=time::Duration::seconds(1), DeliverPred &amp;&amp;pred=DeliverPred())</td></tr>
<tr class="memdesc:a916bbfb779c60dfca6fe6237182ec566"><td class="mdescLeft">&#160;</td><td class="mdescRight">start a client within the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>. The client is powered by a single OS thread.  <a href="#a916bbfb779c60dfca6fe6237182ec566">More...</a><br /></td></tr>
<tr class="separator:a916bbfb779c60dfca6fe6237182ec566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651c95447c4983427e3c6c7e22980900"><td class="memTemplParams" colspan="2">template&lt;typename Client , typename DeliverPred  = deliverAll&gt; </td></tr>
<tr class="memitem:a651c95447c4983427e3c6c7e22980900"><td class="memTemplItemLeft" align="right" valign="top">ClientRegisterHandle&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a651c95447c4983427e3c6c7e22980900">registerToRun</a> (<a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;c, size_t capacity=1024, size_t maxItemSize=<a class="el" href="structhmbdc_1_1max__size__in__tuple.html">max_size_in_tuple</a>&lt; typename Client::Interests &gt;::value, DeliverPred &amp;&amp;pred=DeliverPred())</td></tr>
<tr class="memdesc:a651c95447c4983427e3c6c7e22980900"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as start as to the paramater arguments, except it just register the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> with the context without actually starting the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> thread. The user is epxected to use <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a2929401b8cf825b166c8b00b9954adff" title="run the Client previous registered to process exsiting Messages ">runOnce()</a> to manully power the thread  <a href="#a651c95447c4983427e3c6c7e22980900">More...</a><br /></td></tr>
<tr class="separator:a651c95447c4983427e3c6c7e22980900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2929401b8cf825b166c8b00b9954adff"><td class="memTemplParams" colspan="2">template&lt;typename CcClient &gt; </td></tr>
<tr class="memitem:a2929401b8cf825b166c8b00b9954adff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a2929401b8cf825b166c8b00b9954adff">runOnce</a> (ClientRegisterHandle &amp;t, CcClient &amp;c, <a class="el" href="structhmbdc_1_1time_1_1Duration.html">time::Duration</a> maxBlockingTime=time::Duration::seconds(1))</td></tr>
<tr class="memdesc:a2929401b8cf825b166c8b00b9954adff"><td class="mdescLeft">&#160;</td><td class="mdescRight">run the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> previous registered to process exsiting Messages  <a href="#a2929401b8cf825b166c8b00b9954adff">More...</a><br /></td></tr>
<tr class="separator:a2929401b8cf825b166c8b00b9954adff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdcd32f549e6b07957872cc905a38a8"><td class="memTemplParams" colspan="2">template&lt;typename LoadSharingClientPtrIt , typename DeliverPred  = deliverAll&gt; </td></tr>
<tr class="memitem:abcdcd32f549e6b07957872cc905a38a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#abcdcd32f549e6b07957872cc905a38a8">start</a> (LoadSharingClientPtrIt begin, LoadSharingClientPtrIt end, size_t capacity=1024, size_t maxItemSize=<a class="el" href="structhmbdc_1_1max__size__in__tuple.html">max_size_in_tuple</a>&lt; typename std::decay&lt; decltype(**LoadSharingClientPtrIt())&gt;::type::Interests &gt;::value, uint64_t cpuAffinity=0, <a class="el" href="structhmbdc_1_1time_1_1Duration.html">time::Duration</a> maxBlockingTime=time::Duration::seconds(1), DeliverPred &amp;&amp;pred=DeliverPred())</td></tr>
<tr class="memdesc:abcdcd32f549e6b07957872cc905a38a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">start a group of clients within the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> that collectively processing messages in a load sharing manner. Each client is powered by a single OS thread  <a href="#abcdcd32f549e6b07957872cc905a38a8">More...</a><br /></td></tr>
<tr class="separator:abcdcd32f549e6b07957872cc905a38a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f2fbb00813780045918227ad51c793"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a71f2fbb00813780045918227ad51c793">stop</a> ()</td></tr>
<tr class="memdesc:a71f2fbb00813780045918227ad51c793"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop the message dispatching - asynchronously  <a href="#a71f2fbb00813780045918227ad51c793">More...</a><br /></td></tr>
<tr class="separator:a71f2fbb00813780045918227ad51c793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dbab7e0e853e5cd2c1604d093c8c3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a56dbab7e0e853e5cd2c1604d093c8c3e">join</a> ()</td></tr>
<tr class="memdesc:a56dbab7e0e853e5cd2c1604d093c8c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait until all threads of the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> exit  <a href="#a56dbab7e0e853e5cd2c1604d093c8c3e">More...</a><br /></td></tr>
<tr class="separator:a56dbab7e0e853e5cd2c1604d093c8c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0fe124775a425330c9667194c78b7b"><td class="memTemplParams" colspan="2">template&lt;MessageC Message&gt; </td></tr>
<tr class="memitem:a1c0fe124775a425330c9667194c78b7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a1c0fe124775a425330c9667194c78b7b">send</a> (Message &amp;&amp;m)</td></tr>
<tr class="memdesc:a1c0fe124775a425330c9667194c78b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a message to the <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html" title="A BlockingContext is like a media object that facilitates the communications for the Clients that it ...">BlockingContext</a> to dispatch  <a href="#a1c0fe124775a425330c9667194c78b7b">More...</a><br /></td></tr>
<tr class="separator:a1c0fe124775a425330c9667194c78b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5de7fac115660c0568ef067b90e31d"><td class="memTemplParams" colspan="2">template&lt;MessageC Message, typename ... Args&gt; </td></tr>
<tr class="memitem:a6a5de7fac115660c0568ef067b90e31d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a6a5de7fac115660c0568ef067b90e31d">sendInPlace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6a5de7fac115660c0568ef067b90e31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a message by directly constructing the message in receiving message queue  <a href="#a6a5de7fac115660c0568ef067b90e31d">More...</a><br /></td></tr>
<tr class="separator:a6a5de7fac115660c0568ef067b90e31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82383a067a191d813858d3da5015eead"><td class="memTemplParams" colspan="2">template&lt;MessageC Message&gt; </td></tr>
<tr class="memitem:a82383a067a191d813858d3da5015eead"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a82383a067a191d813858d3da5015eead">trySend</a> (Message &amp;&amp;m, <a class="el" href="structhmbdc_1_1time_1_1Duration.html">time::Duration</a> timeout=time::Duration::seconds(0))</td></tr>
<tr class="memdesc:a82383a067a191d813858d3da5015eead"><td class="mdescLeft">&#160;</td><td class="mdescRight">best effort to send a message to via the <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html" title="A BlockingContext is like a media object that facilitates the communications for the Clients that it ...">BlockingContext</a>  <a href="#a82383a067a191d813858d3da5015eead">More...</a><br /></td></tr>
<tr class="separator:a82383a067a191d813858d3da5015eead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3508b003e2246eb454c74af4651f83a"><td class="memTemplParams" colspan="2">template&lt;MessageC Message, typename ... Args&gt; </td></tr>
<tr class="memitem:ad3508b003e2246eb454c74af4651f83a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#ad3508b003e2246eb454c74af4651f83a">trySendInPlace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad3508b003e2246eb454c74af4651f83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">best effort to send a message by directly constructing the message in receiving message queue  <a href="#ad3508b003e2246eb454c74af4651f83a">More...</a><br /></td></tr>
<tr class="separator:ad3508b003e2246eb454c74af4651f83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936f3195ba6e31143595a044d2f4d383"><td class="memTemplParams" colspan="2">template&lt;MessageForwardIterC ForwardIt&gt; </td></tr>
<tr class="memitem:a936f3195ba6e31143595a044d2f4d383"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a936f3195ba6e31143595a044d2f4d383">send</a> (ForwardIt begin, size_t n)</td></tr>
<tr class="memdesc:a936f3195ba6e31143595a044d2f4d383"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a range of messages via the <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html" title="A BlockingContext is like a media object that facilitates the communications for the Clients that it ...">BlockingContext</a>  <a href="#a936f3195ba6e31143595a044d2f4d383">More...</a><br /></td></tr>
<tr class="separator:a936f3195ba6e31143595a044d2f4d383"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3466a602be6e53c5a2d260ac5d3e9b87"><td class="memTemplParams" colspan="2">template&lt;typename Client , typename RunOnceFunc &gt; </td></tr>
<tr class="memitem:a3466a602be6e53c5a2d260ac5d3e9b87"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a3466a602be6e53c5a2d260ac5d3e9b87">kickOffClientThread</a> (RunOnceFunc runOnceFunc, <a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;c, <a class="el" href="structhmbdc_1_1pattern_1_1BlockingBuffer.html">pattern::BlockingBuffer</a> *buffer, uint64_t mask, <a class="el" href="structhmbdc_1_1time_1_1Duration.html">time::Duration</a> maxBlockingTime)</td></tr>
<tr class="separator:a3466a602be6e53c5a2d260ac5d3e9b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;MessageTupleC... MessageTuples&gt;<br />
class hmbdc::app::BlockingContext&lt; MessageTuples &gt;</h3>

<p>A <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html" title="A BlockingContext is like a media object that facilitates the communications for the Clients that it ...">BlockingContext</a> is like a media object that facilitates the communications for the Clients that it is holding. Each <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is powered by a single OS thread. a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> needs to be started once and only once to a single <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html" title="A BlockingContext is like a media object that facilitates the communications for the Clients that it ...">BlockingContext</a> before any messages sending happens - typically in the initialization stage in main(), undefined behavior otherwise. </p>
<p>a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> running in such a <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html" title="A BlockingContext is like a media object that facilitates the communications for the Clients that it ...">BlockingContext</a> utilizing OS's blocking mechanism and takes less CPU time. The <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a>'s responding time scales better when the number of Clients greatly exceeds the availlable CPUs in the system and the effective message rate for a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> tends to be low. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MessageTuples</td><td>std tuple capturing the Messages that the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> is supposed to deliver. Messages that not listed here are silently dropped to ensure loose coupling between senders and receivers </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a56dbab7e0e853e5cd2c1604d093c8c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dbab7e0e853e5cd2c1604d093c8c3e">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wait until all threads of the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> exit </p>
<p>blocking call </p>

</div>
</div>
<a id="a3466a602be6e53c5a2d260ac5d3e9b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3466a602be6e53c5a2d260ac5d3e9b87">&#9670;&nbsp;</a></span>kickOffClientThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<div class="memtemplate">
template&lt;typename Client , typename RunOnceFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::kickOffClientThread </td>
          <td>(</td>
          <td class="paramtype">RunOnceFunc&#160;</td>
          <td class="paramname"><em>runOnceFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1pattern_1_1BlockingBuffer.html">pattern::BlockingBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1time_1_1Duration.html">time::Duration</a>&#160;</td>
          <td class="paramname"><em>maxBlockingTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>drain all to release sending party </p>

</div>
</div>
<a id="a651c95447c4983427e3c6c7e22980900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651c95447c4983427e3c6c7e22980900">&#9670;&nbsp;</a></span>registerToRun()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<div class="memtemplate">
template&lt;typename Client , typename DeliverPred  = deliverAll&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ClientRegisterHandle <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::registerToRun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxItemSize</em> = <code><a class="el" href="structhmbdc_1_1max__size__in__tuple.html">max_size_in_tuple</a>&lt;typename&#160;Client::Interests&gt;::value</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeliverPred &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>DeliverPred()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>same as start as to the paramater arguments, except it just register the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> with the context without actually starting the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> thread. The user is epxected to use <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html#a2929401b8cf825b166c8b00b9954adff" title="run the Client previous registered to process exsiting Messages ">runOnce()</a> to manully power the thread </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a></td><td>see start() above </td></tr>
    <tr><td class="paramname">DeliverPred</td><td>see start() above </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>see start() above </td></tr>
    <tr><td class="paramname">capacity</td><td>see start() above </td></tr>
    <tr><td class="paramname">maxItemSize</td><td>see start() above </td></tr>
    <tr><td class="paramname">pred</td><td>see start() above </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle that is to be passed back in the runOnce </dd></dl>

</div>
</div>
<a id="a2929401b8cf825b166c8b00b9954adff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2929401b8cf825b166c8b00b9954adff">&#9670;&nbsp;</a></span>runOnce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<div class="memtemplate">
template&lt;typename CcClient &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::runOnce </td>
          <td>(</td>
          <td class="paramtype">ClientRegisterHandle &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CcClient &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1time_1_1Duration.html">time::Duration</a>&#160;</td>
          <td class="paramname"><em>maxBlockingTime</em> = <code>time::Duration::seconds(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>run the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> previous registered to process exsiting Messages </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CcClient</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the handle returned from registerToRun </td></tr>
    <tr><td class="paramname">c</td><td>the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> see start() above </td></tr>
    <tr><td class="paramname">maxBlockingTime</td><td>see start() above </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> did not terminate itself by throwing an exeption </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a1c0fe124775a425330c9667194c78b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0fe124775a425330c9667194c78b7b">&#9670;&nbsp;</a></span>send() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<div class="memtemplate">
template&lt;MessageC Message&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::send </td>
          <td>(</td>
          <td class="paramtype">Message &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send a message to the <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html" title="A BlockingContext is like a media object that facilitates the communications for the Clients that it ...">BlockingContext</a> to dispatch </p>
<p>only the Clients that handles the Message will get it This function is threadsafe, which means you can call it anywhere in the code</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a936f3195ba6e31143595a044d2f4d383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936f3195ba6e31143595a044d2f4d383">&#9670;&nbsp;</a></span>send() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<div class="memtemplate">
template&lt;MessageForwardIterC ForwardIt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::send </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send a range of messages via the <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html" title="A BlockingContext is like a media object that facilitates the communications for the Clients that it ...">BlockingContext</a> </p>
<ul>
<li>only checking with deliverPred using the first message</li>
</ul>
<p>only the Clients that handles the Message will get it of course This function is threadsafe, which means you can call it anywhere in the code</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>a forward iterator point at the start of the range </td></tr>
    <tr><td class="paramname">n</td><td>length of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a5de7fac115660c0568ef067b90e31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5de7fac115660c0568ef067b90e31d">&#9670;&nbsp;</a></span>sendInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<div class="memtemplate">
template&lt;MessageC Message, typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::sendInPlace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send a message by directly constructing the message in receiving message queue </p>
<p>since the message only exists after being deleivered, the DeliverPred is not called to decide if it should be delivered</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>ctor args </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>type </td></tr>
    <tr><td class="paramname">typename</td><td>... Args args </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a916bbfb779c60dfca6fe6237182ec566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916bbfb779c60dfca6fe6237182ec566">&#9670;&nbsp;</a></span>start() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<div class="memtemplate">
template&lt;typename Client , typename DeliverPred  = deliverAll&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxItemSize</em> = <code><a class="el" href="structhmbdc_1_1max__size__in__tuple.html">max_size_in_tuple</a>&lt;typename&#160;Client::Interests&gt;::value</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cpuAffinity</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1time_1_1Duration.html">time::Duration</a>&#160;</td>
          <td class="paramname"><em>maxBlockingTime</em> = <code>time::Duration::seconds(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeliverPred &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>DeliverPred()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start a client within the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>. The client is powered by a single OS thread. </p>
<p>it is ok if a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is blocking, if its own buffer is not full, it doesn't affect other <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a>'s capabilities of receiving Messages</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a></td><td>actual <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> type </td></tr>
    <tr><td class="paramname">DeliverPred</td><td>a condition functor deciding if a message should be delivered to a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a>, which provides filtering before the Message type filtering. It improves performance in the way it could potentially reduce the unblocking times of thread</td></tr>
  </table>
  </dd>
</dl>
<p>Usage example: //the following Pred verifies srcId matches for Response, and let all other Messages types //deliver </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Pred {</div><div class="line">Pred(uint16_t srcId)</div><div class="line">    : srcId(srcId){}</div><div class="line">   </div><div class="line">    <span class="keywordtype">bool</span> operator()(Response <span class="keyword">const</span>&amp; resp) {</div><div class="line">        <span class="keywordflow">return</span> resp.srcId == srcId;</div><div class="line">    }</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M&gt;</div><div class="line">    <span class="keywordtype">bool</span> operator()(M <span class="keyword">const</span>&amp;) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}</div><div class="line"></div><div class="line">    uint16_t srcId;</div><div class="line">};</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td><a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> </td></tr>
    <tr><td class="paramname">capacity</td><td>the maximum messages this <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> can buffer </td></tr>
    <tr><td class="paramname">maxItemSize</td><td>the max size of a message - when the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is interetsed in <a class="el" href="structhmbdc_1_1app_1_1JustBytes.html" title="A special type of message only used on the receiving side. ">JustBytes</a>, this value MUST be big enough to hold the max size message to avoid truncation </td></tr>
    <tr><td class="paramname">cpuAffinity</td><td>cpu affinity mask for this <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a>'s thread </td></tr>
    <tr><td class="paramname">maxBlockingTime</td><td>it is recommended to limit the duration a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> blocks due to no messages to handle, so it can respond to things like <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> is stopped, or generate heartbeats if applicable. </td></tr>
    <tr><td class="paramname">pred</td><td>see DeliverPred documentation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcdcd32f549e6b07957872cc905a38a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdcd32f549e6b07957872cc905a38a8">&#9670;&nbsp;</a></span>start() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<div class="memtemplate">
template&lt;typename LoadSharingClientPtrIt , typename DeliverPred  = deliverAll&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::start </td>
          <td>(</td>
          <td class="paramtype">LoadSharingClientPtrIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoadSharingClientPtrIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxItemSize</em> = <code><a class="el" href="structhmbdc_1_1max__size__in__tuple.html">max_size_in_tuple</a>&lt;&#160;typename&#160;std::decay&lt;decltype(**LoadSharingClientPtrIt())&gt;::type::Interests&#160;&gt;::value</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cpuAffinity</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1time_1_1Duration.html">time::Duration</a>&#160;</td>
          <td class="paramname"><em>maxBlockingTime</em> = <code>time::Duration::seconds(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeliverPred &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>DeliverPred()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start a group of clients within the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> that collectively processing messages in a load sharing manner. Each client is powered by a single OS thread </p>
<p>it is ok if a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is blocking, if its own buffer is not full, it doesn't affect other <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a>'s capabilities of receiving Messages</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LoadSharingClientPtrIt</td><td>iterator to a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> pointer </td></tr>
    <tr><td class="paramname">DeliverPred</td><td>a condition functor deciding if a message should be delivered to these Clients, which provides filtering before the Message type filtering. It improves performance in the way it could potentially reduce the unblocking times of threads. An exception is for <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> that are interested in <a class="el" href="structhmbdc_1_1app_1_1JustBytes.html" title="A special type of message only used on the receiving side. ">JustBytes</a> (basically every message), this filter does not apply - no filtering for these Clients</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator, **begin should produce a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a>&amp; for the first <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> </td></tr>
    <tr><td class="paramname">end</td><td>an end iterator, [begin, end) is the range for Clients </td></tr>
    <tr><td class="paramname">capacity</td><td>the maximum messages this <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> can buffer </td></tr>
    <tr><td class="paramname">maxItemSize</td><td>the max size of a message - when the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is interetsed in <a class="el" href="structhmbdc_1_1app_1_1JustBytes.html" title="A special type of message only used on the receiving side. ">JustBytes</a>, this value MUST be big enough to hold the max size message to avoid truncation </td></tr>
    <tr><td class="paramname">cpuAffinity</td><td>cpu affinity mask for this <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a>'s thread </td></tr>
    <tr><td class="paramname">maxBlockingTime</td><td>it is recommended to limit the duration a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> blocks due to no messages to handle, so it can respond to things like <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> is stopped, or generate heartbeats if applicable. </td></tr>
    <tr><td class="paramname">pred</td><td>see DeliverPred documentation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71f2fbb00813780045918227ad51c793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f2fbb00813780045918227ad51c793">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stop the message dispatching - asynchronously </p>
<p>asynchronously means not garanteed message dispatching stops immidiately after this non-blocking call </p>

</div>
</div>
<a id="a82383a067a191d813858d3da5015eead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82383a067a191d813858d3da5015eead">&#9670;&nbsp;</a></span>trySend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<div class="memtemplate">
template&lt;MessageC Message&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::trySend </td>
          <td>(</td>
          <td class="paramtype">Message &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1time_1_1Duration.html">time::Duration</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>time::Duration::seconds(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>best effort to send a message to via the <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html" title="A BlockingContext is like a media object that facilitates the communications for the Clients that it ...">BlockingContext</a> </p>
<p>this method is not recommended if more than one recipients are accepting this message since there is no garantee each one will receive it once and only once. this call does not block - return false when deliver doesn't reach all intended recipients This method is threadsafe, which means you can call it anywhere in the code</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>message </td></tr>
    <tr><td class="paramname">timeout</td><td>return false if cannot deliver in the specified time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if send successfully to every intended receiver </dd></dl>

</div>
</div>
<a id="ad3508b003e2246eb454c74af4651f83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3508b003e2246eb454c74af4651f83a">&#9670;&nbsp;</a></span>trySendInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MessageTupleC... MessageTuples&gt; </div>
<div class="memtemplate">
template&lt;MessageC Message, typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structhmbdc_1_1app_1_1BlockingContext.html">hmbdc::app::BlockingContext</a>&lt; MessageTuples &gt;::trySendInPlace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>best effort to send a message by directly constructing the message in receiving message queue </p>
<p>since the message only exists after being deleivered, the DeliverPred is not called to decide if it should be delivered this method is not recommended if more than one recipients are accepting this message since it is hard to ensure each message is delivered once and only once. this call does not block - return false when delivery doesn't reach ALL intended recipients This method is threadsafe, which means you can call it anywhere in the code</p>
<dl class="section return"><dt>Returns</dt><dd>true if send successfully to every intended receiver </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hmbdc/app/<a class="el" href="BlockingContext_8hpp_source.html">BlockingContext.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
