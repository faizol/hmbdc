<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hmbdc: hmbdc::app::ClientWithStash&lt; CcClient, MaxStashedMessageSizeIn, Messages &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hmbdc
   </div>
   <div id="projectbrief">simplify-high-performance-messaging-programming</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehmbdc.html">hmbdc</a></li><li class="navelem"><a class="el" href="namespacehmbdc_1_1app.html">app</a></li><li class="navelem"><a class="el" href="structhmbdc_1_1app_1_1ClientWithStash.html">ClientWithStash</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="structhmbdc_1_1app_1_1ClientWithStash-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hmbdc::app::ClientWithStash&lt; CcClient, MaxStashedMessageSizeIn, Messages &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>It behaves like <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a>, with the extra capability of storing messages received and processing them later - it is used when the user wants to process messages in a specific order other than FIFO. If a message is deemed to come too early, just stash it and move on (to the next message). The stashed messages will be delivered later at the user's choice - see the added stash and openStash functions. The stash mechanism can enforce any particular order of message processing regarless of the order of message being sent.  
 <a href="structhmbdc_1_1app_1_1ClientWithStash.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ClientWithStash_8hpp_source.html">ClientWithStash.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for hmbdc::app::ClientWithStash&lt; CcClient, MaxStashedMessageSizeIn, Messages &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structhmbdc_1_1app_1_1ClientWithStash.png" usemap="#hmbdc::app::ClientWithStash_3C_20CcClient_2C_20MaxStashedMessageSizeIn_2C_20Messages_20_3E_map" alt=""/>
  <map id="hmbdc::app::ClientWithStash_3C_20CcClient_2C_20MaxStashedMessageSizeIn_2C_20Messages_20_3E_map" name="hmbdc::app::ClientWithStash_3C_20CcClient_2C_20MaxStashedMessageSizeIn_2C_20Messages_20_3E_map">
<area href="structhmbdc_1_1app_1_1Client.html" alt="hmbdc::app::Client&lt; CcClient, Messages... &gt;" shape="rect" coords="0,0,470,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa8141f49ff29b8dc36e1aae9bc228406"><td class="memTemplParams" colspan="2"><a id="aa8141f49ff29b8dc36e1aae9bc228406"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aa8141f49ff29b8dc36e1aae9bc228406"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1ClientWithStash.html#aa8141f49ff29b8dc36e1aae9bc228406">handleRangeImpl</a> (Iterator it, Iterator end, uint16_t threadId)</td></tr>
<tr class="memdesc:aa8141f49ff29b8dc36e1aae9bc228406"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not touch - internal use <br /></td></tr>
<tr class="separator:aa8141f49ff29b8dc36e1aae9bc228406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structhmbdc_1_1app_1_1Client"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structhmbdc_1_1app_1_1Client')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client&lt; CcClient, Messages... &gt;</a></td></tr>
<tr class="memitem:a91448c0e9b4a40c1ab9fa795aa1175b5 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#a91448c0e9b4a40c1ab9fa795aa1175b5">hmbdcName</a> () const</td></tr>
<tr class="memdesc:a91448c0e9b4a40c1ab9fa795aa1175b5 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the name of thread that runs this client, override if necessary  <a href="structhmbdc_1_1app_1_1Client.html#a91448c0e9b4a40c1ab9fa795aa1175b5">More...</a><br /></td></tr>
<tr class="separator:a91448c0e9b4a40c1ab9fa795aa1175b5 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1fe10601c73c7915253982ab7f0f8b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; char const *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#abe1fe10601c73c7915253982ab7f0f8b">schedSpec</a> () const</td></tr>
<tr class="memdesc:abe1fe10601c73c7915253982ab7f0f8b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">an overrideable method. returns the schedule policy and priority, override if necessary priority is only used when policy is "SCHED_RR", or "SCHED_FIFO"  <a href="structhmbdc_1_1app_1_1Client.html#abe1fe10601c73c7915253982ab7f0f8b">More...</a><br /></td></tr>
<tr class="separator:abe1fe10601c73c7915253982ab7f0f8b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12b8f43afb684949bec0ac3949724c8 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ad12b8f43afb684949bec0ac3949724c8">maxBatchMessageCount</a> () const</td></tr>
<tr class="memdesc:ad12b8f43afb684949bec0ac3949724c8 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">an overridable method. client receives events in batches and the max batch size is controllable when running in direct mode Context. Here is to specify the max size.  <a href="structhmbdc_1_1app_1_1Client.html#ad12b8f43afb684949bec0ac3949724c8">More...</a><br /></td></tr>
<tr class="separator:ad12b8f43afb684949bec0ac3949724c8 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11a96a305f27f829a87c8961ada7829 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ab11a96a305f27f829a87c8961ada7829">messageDispatchingStartedCb</a> (size_t const *pClientDispatchingStarted)</td></tr>
<tr class="memdesc:ab11a96a305f27f829a87c8961ada7829 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">called before any messages got dispatched - only once  <a href="structhmbdc_1_1app_1_1Client.html#ab11a96a305f27f829a87c8961ada7829">More...</a><br /></td></tr>
<tr class="separator:ab11a96a305f27f829a87c8961ada7829 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78385b2e94320057dce7b695f720d703 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#a78385b2e94320057dce7b695f720d703">stoppedCb</a> (std::exception const &amp;e)</td></tr>
<tr class="memdesc:a78385b2e94320057dce7b695f720d703 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback called when this Client is taken out of message dispatching  <a href="structhmbdc_1_1app_1_1Client.html#a78385b2e94320057dce7b695f720d703">More...</a><br /></td></tr>
<tr class="separator:a78385b2e94320057dce7b695f720d703 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d37734943cba95f1a57536b3d1d49b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ae0d37734943cba95f1a57536b3d1d49b">droppedCb</a> ()</td></tr>
<tr class="memdesc:ae0d37734943cba95f1a57536b3d1d49b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback called after the Client is safely taken out of the Context  <a href="structhmbdc_1_1app_1_1Client.html#ae0d37734943cba95f1a57536b3d1d49b">More...</a><br /></td></tr>
<tr class="separator:ae0d37734943cba95f1a57536b3d1d49b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccfe91867a470c8159cf6b5f67c4821 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#a7ccfe91867a470c8159cf6b5f67c4821">invokedCb</a> (size_t dispatched)</td></tr>
<tr class="memdesc:a7ccfe91867a470c8159cf6b5f67c4821 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">this callback is called all the time (frequently) - the exact timing is after a batch of messages are dispatched. After this call returns, the previously dispatched message's addresses are no longer valid, which means if you cache the event addresses in the previous handleMessageCb()s, you cannot use those after the return of the next invokeCb function.  <a href="structhmbdc_1_1app_1_1Client.html#a7ccfe91867a470c8159cf6b5f67c4821">More...</a><br /></td></tr>
<tr class="separator:a7ccfe91867a470c8159cf6b5f67c4821 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58a71bea254993fda723e83b7adbe76 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top"><a id="ad58a71bea254993fda723e83b7adbe76"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ad58a71bea254993fda723e83b7adbe76">~Client</a> ()</td></tr>
<tr class="memdesc:ad58a71bea254993fda723e83b7adbe76 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">trivial <br /></td></tr>
<tr class="separator:ad58a71bea254993fda723e83b7adbe76 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e562879c6bb4623c6c86f2b1e5b1b3 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top"><a id="a03e562879c6bb4623c6c86f2b1e5b1b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#a03e562879c6bb4623c6c86f2b1e5b1b3">stopped</a> (std::exception const &amp;e) noexcept</td></tr>
<tr class="memdesc:a03e562879c6bb4623c6c86f2b1e5b1b3 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">the following are for internal use, don't change or override <br /></td></tr>
<tr class="separator:a03e562879c6bb4623c6c86f2b1e5b1b3 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4beb50da3e231c579d2969a1c839e7b0"><td class="memTemplParams" colspan="2">template&lt;MessageC Message&gt; </td></tr>
<tr class="memitem:a4beb50da3e231c579d2969a1c839e7b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1ClientWithStash.html#a4beb50da3e231c579d2969a1c839e7b0">stash</a> (Message const &amp;message)</td></tr>
<tr class="memdesc:a4beb50da3e231c579d2969a1c839e7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">stash a message that will be delivered later to the same callback  <a href="#a4beb50da3e231c579d2969a1c839e7b0">More...</a><br /></td></tr>
<tr class="separator:a4beb50da3e231c579d2969a1c839e7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf55a2dc0d4fd70938d287f4a4d7c14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1ClientWithStash.html#acbf55a2dc0d4fd70938d287f4a4d7c14">openStash</a> ()</td></tr>
<tr class="memdesc:acbf55a2dc0d4fd70938d287f4a4d7c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">release the stashed messages - after this call is returned, the callbacks of the stahsed message will be invoked with the stashed messages  <a href="#acbf55a2dc0d4fd70938d287f4a4d7c14">More...</a><br /></td></tr>
<tr class="separator:acbf55a2dc0d4fd70938d287f4a4d7c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_structhmbdc_1_1app_1_1Client"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_structhmbdc_1_1app_1_1Client')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client&lt; CcClient, Messages... &gt;</a></td></tr>
<tr class="memitem:acc50d1e9440a88f0311aee3f95d4305b inherit pro_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#acc50d1e9440a88f0311aee3f95d4305b">batchDone</a> ()</td></tr>
<tr class="memdesc:acc50d1e9440a88f0311aee3f95d4305b inherit pro_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">the derived user's Client has the option to stop the current batch of event dispatching.  <a href="structhmbdc_1_1app_1_1Client.html#acc50d1e9440a88f0311aee3f95d4305b">More...</a><br /></td></tr>
<tr class="separator:acc50d1e9440a88f0311aee3f95d4305b inherit pro_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename CcClient, size_t MaxStashedMessageSizeIn, MessageC ... Messages&gt;<br />
class hmbdc::app::ClientWithStash&lt; CcClient, MaxStashedMessageSizeIn, Messages &gt;</h3>

<p>It behaves like <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a>, with the extra capability of storing messages received and processing them later - it is used when the user wants to process messages in a specific order other than FIFO. If a message is deemed to come too early, just stash it and move on (to the next message). The stashed messages will be delivered later at the user's choice - see the added stash and openStash functions. The stash mechanism can enforce any particular order of message processing regarless of the order of message being sent. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CcClient</td><td>the concrete <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> type </td></tr>
    <tr><td class="paramname">MaxStashedMessageSizeIn</td><td>byte size of the max message that will need to be stashed, use 0 to auto-set to hold the max interested message </td></tr>
    <tr><td class="paramname">typename</td><td>... Messages message types that the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> interested </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acbf55a2dc0d4fd70938d287f4a4d7c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf55a2dc0d4fd70938d287f4a4d7c14">&#9670;&nbsp;</a></span>openStash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcClient , size_t MaxStashedMessageSizeIn, MessageC ... Messages&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1ClientWithStash.html">hmbdc::app::ClientWithStash</a>&lt; CcClient, MaxStashedMessageSizeIn, Messages &gt;::openStash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release the stashed messages - after this call is returned, the callbacks of the stahsed message will be invoked with the stashed messages </p>
<p>it is fine to stash more / new messages even in the above callbacks invoked due to stashed messages </p>

</div>
</div>
<a id="a4beb50da3e231c579d2969a1c839e7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4beb50da3e231c579d2969a1c839e7b0">&#9670;&nbsp;</a></span>stash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcClient , size_t MaxStashedMessageSizeIn, MessageC ... Messages&gt; </div>
<div class="memtemplate">
template&lt;MessageC Message&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1ClientWithStash.html">hmbdc::app::ClientWithStash</a>&lt; CcClient, MaxStashedMessageSizeIn, Messages &gt;::stash </td>
          <td>(</td>
          <td class="paramtype">Message const &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stash a message that will be delivered later to the same callback </p>
<p>when the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> decide a message is not ready to be handled now but is needed later, it calls this message to stash it, see also <a class="el" href="structhmbdc_1_1app_1_1ClientWithStash.html#acbf55a2dc0d4fd70938d287f4a4d7c14" title="release the stashed messages - after this call is returned, the callbacks of the stahsed message will...">openStash()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>the message to be stashed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hmbdc/app/<a class="el" href="ClientWithStash_8hpp_source.html">ClientWithStash.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
