<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hmbdc: hmbdc::tips::Node&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hmbdc
   </div>
   <div id="projectbrief">simplify-high-performance-messaging-programming</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hmbdc</b></li><li class="navelem"><b>tips</b></li><li class="navelem"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html">Node&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hmbdc::tips::Node&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for hmbdc::tips::Node&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.png" usemap="#hmbdc::tips::Node_3C_20CcNode_2C_20std::tuple_3C_20RecvMessages..._20_3E_2C_20HasMessageStash_20_3E_map" alt=""/>
  <map id="hmbdc::tips::Node_3C_20CcNode_2C_20std::tuple_3C_20RecvMessages..._20_3E_2C_20HasMessageStash_20_3E_map" name="hmbdc::tips::Node_3C_20CcNode_2C_20std::tuple_3C_20RecvMessages..._20_3E_2C_20HasMessageStash_20_3E_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a52bbb5daa585e8da41b3c4b0521f3a5d"><td class="memItemLeft" align="right" valign="top"><a id="a52bbb5daa585e8da41b3c4b0521f3a5d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html#a52bbb5daa585e8da41b3c4b0521f3a5d">SendMessageTuple</a> = std::tuple&lt;&gt;</td></tr>
<tr class="memdesc:a52bbb5daa585e8da41b3c4b0521f3a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> needs to specify a list of Messages that would be sent out if this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is active to help IPC and network delivering filtering. If not fully specified the message could be invisible outside of this process. <br /></td></tr>
<tr class="separator:a52bbb5daa585e8da41b3c4b0521f3a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f6861e3be832ef8fba9fc456b578a33"><td class="memItemLeft" align="right" valign="top">char const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html#a1f6861e3be832ef8fba9fc456b578a33">hmbdcName</a> () const</td></tr>
<tr class="memdesc:a1f6861e3be832ef8fba9fc456b578a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">the thread name used to identify the thread the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is running on  <a href="#a1f6861e3be832ef8fba9fc456b578a33">More...</a><br /></td></tr>
<tr class="separator:a1f6861e3be832ef8fba9fc456b578a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95877d06e7d2750c254959763f3154bc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html#a95877d06e7d2750c254959763f3154bc">maxMessageSize</a> () const</td></tr>
<tr class="memdesc:a95877d06e7d2750c254959763f3154bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">unless JustBytes is used in <a class="el" href="classInterests.html" title="a std tuple holding messages types it can dispatch ">Interests</a> - this is automatic  <a href="#a95877d06e7d2750c254959763f3154bc">More...</a><br /></td></tr>
<tr class="separator:a95877d06e7d2750c254959763f3154bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ee17cb31f73b867f53728c56dca6dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html#a51ee17cb31f73b867f53728c56dca6dc">addJustBytesSubsFor</a> (std::function&lt; void(uint16_t)&gt; addTag) const</td></tr>
<tr class="memdesc:a51ee17cb31f73b867f53728c56dca6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">What tags are going to published when JustBytes is in the RecvMessageTuple.  <a href="#a51ee17cb31f73b867f53728c56dca6dc">More...</a><br /></td></tr>
<tr class="separator:a51ee17cb31f73b867f53728c56dca6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac672b373cddd603481be057810a671da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html#ac672b373cddd603481be057810a671da">addJustBytesPubsFor</a> (std::function&lt; void(uint16_t)&gt; addTag) const</td></tr>
<tr class="memdesc:ac672b373cddd603481be057810a671da"><td class="mdescLeft">&#160;</td><td class="mdescRight">What tags are going to published when JustBytes is in the SendMessageTuple.  <a href="#ac672b373cddd603481be057810a671da">More...</a><br /></td></tr>
<tr class="separator:ac672b373cddd603481be057810a671da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85270b28215c3001b89307d6f2f39ce"><td class="memTemplParams" colspan="2">template&lt;app::MessageC Message&gt; </td></tr>
<tr class="memitem:aa85270b28215c3001b89307d6f2f39ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html#aa85270b28215c3001b89307d6f2f39ce">addTypeTagRangeSubsFor</a> (Message *, std::function&lt; void(uint16_t)&gt; addOffsetInRange) const</td></tr>
<tr class="memdesc:aa85270b28215c3001b89307d6f2f39ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concrete node overrides this function for each inTagRange type of Message to indicate which type tags in the range this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> subscribes for - otherwise each one in range is subscribed.  <a href="#aa85270b28215c3001b89307d6f2f39ce">More...</a><br /></td></tr>
<tr class="separator:aa85270b28215c3001b89307d6f2f39ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230f106312762dd83ab446561fbf4984"><td class="memTemplParams" colspan="2">template&lt;app::MessageC Message&gt; </td></tr>
<tr class="memitem:a230f106312762dd83ab446561fbf4984"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html#a230f106312762dd83ab446561fbf4984">addTypeTagRangePubsFor</a> (Message *, std::function&lt; void(uint16_t)&gt; addOffsetInRange) const</td></tr>
<tr class="memdesc:a230f106312762dd83ab446561fbf4984"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concrete node overrides this function for each inTagRange type of Message to indicate which type tags in the range this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> subscribes for - otherwise each one in range is expected to be published.  <a href="#a230f106312762dd83ab446561fbf4984">More...</a><br /></td></tr>
<tr class="separator:a230f106312762dd83ab446561fbf4984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27db064c91ce90ae26387a97d1a632e6"><td class="memItemLeft" align="right" valign="top"><a id="a27db064c91ce90ae26387a97d1a632e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html#a27db064c91ce90ae26387a97d1a632e6">updateSubscription</a> ()</td></tr>
<tr class="memdesc:a27db064c91ce90ae26387a97d1a632e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> calls this first before handles the subscritions for this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a>. <br /></td></tr>
<tr class="separator:a27db064c91ce90ae26387a97d1a632e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f66f604fa645bcdf5222619926ba14d"><td class="memTemplParams" colspan="2">template&lt;app::MessageC Message&gt; </td></tr>
<tr class="memitem:a9f66f604fa645bcdf5222619926ba14d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html#a9f66f604fa645bcdf5222619926ba14d">ifDeliver</a> (Message const &amp;message) const</td></tr>
<tr class="memdesc:a9f66f604fa645bcdf5222619926ba14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">an overridable method in the concrete <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> that determine if a message should be deliverred to this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> instance This is called at the sending part before the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is unblocked due to this delivery  <a href="#a9f66f604fa645bcdf5222619926ba14d">More...</a><br /></td></tr>
<tr class="separator:a9f66f604fa645bcdf5222619926ba14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68e5e9a47834b5c731fbc2972862877"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html#ac68e5e9a47834b5c731fbc2972862877">ifDeliver</a> (uint16_t tag, uint8_t const *bytes) const</td></tr>
<tr class="memdesc:ac68e5e9a47834b5c731fbc2972862877"><td class="mdescLeft">&#160;</td><td class="mdescRight">an overridable method in the concrete <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> that determine if a message should be deliverred to this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> instance's JustBytes <a class="el" href="classInterests.html" title="a std tuple holding messages types it can dispatch ">Interests</a> This is called at the sending part before the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is unblocked due to this delivery  <a href="#ac68e5e9a47834b5c731fbc2972862877">More...</a><br /></td></tr>
<tr class="separator:ac68e5e9a47834b5c731fbc2972862877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2d5016b97e3180968a47afed717043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node_3_01CcNode_00_01std_1_1tuple_3_01RecvMessages_8_8_8_01_4_00_01HasMessageStash_01_4.html#adc2d5016b97e3180968a47afed717043">invokedCb</a> (size_t dispatched) override</td></tr>
<tr class="memdesc:adc2d5016b97e3180968a47afed717043"><td class="mdescLeft">&#160;</td><td class="mdescRight">this callback is called all the time (frequently) - the exact timing is after a batch of messages are dispatched. After this call returns, the previously dispatched message's addresses are no longer valid, which means if you cache the event addresses in the previous handleMessageCb()s, you cannot use those after the return of the next invokeCb function.  <a href="#adc2d5016b97e3180968a47afed717043">More...</a><br /></td></tr>
<tr class="separator:adc2d5016b97e3180968a47afed717043"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac672b373cddd603481be057810a671da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac672b373cddd603481be057810a671da">&#9670;&nbsp;</a></span>addJustBytesPubsFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageC ... RecvMessages, bool HasMessageStash&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt;::addJustBytesPubsFor </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(uint16_t)&gt;&#160;</td>
          <td class="paramname"><em>addTag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What tags are going to published when JustBytes is in the SendMessageTuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addTag</td><td>functor used to addd a tag value (NOT tag offset) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51ee17cb31f73b867f53728c56dca6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ee17cb31f73b867f53728c56dca6dc">&#9670;&nbsp;</a></span>addJustBytesSubsFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageC ... RecvMessages, bool HasMessageStash&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt;::addJustBytesSubsFor </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(uint16_t)&gt;&#160;</td>
          <td class="paramname"><em>addTag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What tags are going to published when JustBytes is in the RecvMessageTuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addTag</td><td>functor used to addd a tag value (NOT tag offset) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a230f106312762dd83ab446561fbf4984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230f106312762dd83ab446561fbf4984">&#9670;&nbsp;</a></span>addTypeTagRangePubsFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageC ... RecvMessages, bool HasMessageStash&gt; </div>
<div class="memtemplate">
template&lt;app::MessageC Message&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt;::addTypeTagRangePubsFor </td>
          <td>(</td>
          <td class="paramtype">Message *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(uint16_t)&gt;&#160;</td>
          <td class="paramname"><em>addOffsetInRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The concrete node overrides this function for each inTagRange type of Message to indicate which type tags in the range this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> subscribes for - otherwise each one in range is expected to be published. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>the inTagRange Message </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addOffsetInRange</td><td>a functor that adds a type tag into the subscription Note - the functor does not take a type tag - instead it takes the tag offset within the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa85270b28215c3001b89307d6f2f39ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85270b28215c3001b89307d6f2f39ce">&#9670;&nbsp;</a></span>addTypeTagRangeSubsFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageC ... RecvMessages, bool HasMessageStash&gt; </div>
<div class="memtemplate">
template&lt;app::MessageC Message&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt;::addTypeTagRangeSubsFor </td>
          <td>(</td>
          <td class="paramtype">Message *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(uint16_t)&gt;&#160;</td>
          <td class="paramname"><em>addOffsetInRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The concrete node overrides this function for each inTagRange type of Message to indicate which type tags in the range this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> subscribes for - otherwise each one in range is subscribed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>the inTagRange Message </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addOffsetInRange</td><td>a functor that adds a type tag into the subscription Note - the functor does not take a type tag - instead it takes the tag offset within the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f6861e3be832ef8fba9fc456b578a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6861e3be832ef8fba9fc456b578a33">&#9670;&nbsp;</a></span>hmbdcName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageC ... RecvMessages, bool HasMessageStash&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char const* <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt;::hmbdcName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the thread name used to identify the thread the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is running on </p>
<ul>
<li>only for display purpose</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>char const* a string - less than 8 char typically </dd></dl>

</div>
</div>
<a id="a9f66f604fa645bcdf5222619926ba14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f66f604fa645bcdf5222619926ba14d">&#9670;&nbsp;</a></span>ifDeliver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageC ... RecvMessages, bool HasMessageStash&gt; </div>
<div class="memtemplate">
template&lt;app::MessageC Message&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt;::ifDeliver </td>
          <td>(</td>
          <td class="paramtype">Message const &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an overridable method in the concrete <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> that determine if a message should be deliverred to this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> instance This is called at the sending part before the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is unblocked due to this delivery </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>decision is for this Message type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The decision on this Message instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if proceed to deliever it </dd>
<dd>
false if not </dd></dl>

</div>
</div>
<a id="ac68e5e9a47834b5c731fbc2972862877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68e5e9a47834b5c731fbc2972862877">&#9670;&nbsp;</a></span>ifDeliver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageC ... RecvMessages, bool HasMessageStash&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt;::ifDeliver </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an overridable method in the concrete <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> that determine if a message should be deliverred to this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> instance's JustBytes <a class="el" href="classInterests.html" title="a std tuple holding messages types it can dispatch ">Interests</a> This is called at the sending part before the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is unblocked due to this delivery </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>decision is for this Message type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>message tag </td></tr>
    <tr><td class="paramname">bytes</td><td>message address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if proceed to deliever it </dd>
<dd>
false if not </dd></dl>

</div>
</div>
<a id="adc2d5016b97e3180968a47afed717043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2d5016b97e3180968a47afed717043">&#9670;&nbsp;</a></span>invokedCb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageC ... RecvMessages, bool HasMessageStash&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt;::invokedCb </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dispatched</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this callback is called all the time (frequently) - the exact timing is after a batch of messages are dispatched. After this call returns, the previously dispatched message's addresses are no longer valid, which means if you cache the event addresses in the previous handleMessageCb()s, you cannot use those after the return of the next invokeCb function. </p>
<p>you can collectively process the messages received/cached so far here, or do something needs to be done all the time like powering another message loop</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatched</td><td>the number of messages dispatched since last invokedCb called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95877d06e7d2750c254959763f3154bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95877d06e7d2750c254959763f3154bc">&#9670;&nbsp;</a></span>maxMessageSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageC ... RecvMessages, bool HasMessageStash&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, std::tuple&lt; RecvMessages... &gt;, HasMessageStash &gt;::maxMessageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unless JustBytes is used in <a class="el" href="classInterests.html" title="a std tuple holding messages types it can dispatch ">Interests</a> - this is automatic </p>
<dl class="section return"><dt>Returns</dt><dd>size_t what is the biggest message this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is to receive </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>hmbdc/tips/<a class="el" href="Node_8hpp_source.html">Node.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
