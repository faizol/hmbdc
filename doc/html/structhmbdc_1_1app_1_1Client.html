<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hmbdc: hmbdc::app::Client&lt; CcClient, Messages &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hmbdc
   </div>
   <div id="projectbrief">simplify-high-performance-messaging-programming</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hmbdc</b></li><li class="navelem"><a class="el" href="namespacehmbdc_1_1app.html">app</a></li><li class="navelem"><a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="structhmbdc_1_1app_1_1Client-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hmbdc::app::Client&lt; CcClient, Messages &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> represents a thread of execution/a task. The execution is managed by a <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>. a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> object could participate in message dispatching as the receiver of specifed message types.  
 <a href="structhmbdc_1_1app_1_1Client.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Client_8hpp_source.html">Client.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91448c0e9b4a40c1ab9fa795aa1175b5"><td class="memItemLeft" align="right" valign="top">char const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#a91448c0e9b4a40c1ab9fa795aa1175b5">hmbdcName</a> () const</td></tr>
<tr class="memdesc:a91448c0e9b4a40c1ab9fa795aa1175b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the name of thread that runs this client, override if necessary  <a href="#a91448c0e9b4a40c1ab9fa795aa1175b5">More...</a><br /></td></tr>
<tr class="separator:a91448c0e9b4a40c1ab9fa795aa1175b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1fe10601c73c7915253982ab7f0f8b"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; char const  *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#abe1fe10601c73c7915253982ab7f0f8b">schedSpec</a> () const</td></tr>
<tr class="memdesc:abe1fe10601c73c7915253982ab7f0f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">an overrideable method. returns the schedule policy and priority, override if necessary priority is only used when policy is "SCHED_RR", or "SCHED_FIFO"  <a href="#abe1fe10601c73c7915253982ab7f0f8b">More...</a><br /></td></tr>
<tr class="separator:abe1fe10601c73c7915253982ab7f0f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12b8f43afb684949bec0ac3949724c8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ad12b8f43afb684949bec0ac3949724c8">maxBatchMessageCount</a> () const</td></tr>
<tr class="memdesc:ad12b8f43afb684949bec0ac3949724c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">an overridable method. client receives events in batches and the max batch size is controllable when running in direct mode <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>. Here is to specify the max size.  <a href="#ad12b8f43afb684949bec0ac3949724c8">More...</a><br /></td></tr>
<tr class="separator:ad12b8f43afb684949bec0ac3949724c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11a96a305f27f829a87c8961ada7829"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ab11a96a305f27f829a87c8961ada7829">messageDispatchingStartedCb</a> (size_t const *pClientDispatchingStarted)</td></tr>
<tr class="memdesc:ab11a96a305f27f829a87c8961ada7829"><td class="mdescLeft">&#160;</td><td class="mdescRight">called before any messages got dispatched - only once  <a href="#ab11a96a305f27f829a87c8961ada7829">More...</a><br /></td></tr>
<tr class="separator:ab11a96a305f27f829a87c8961ada7829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78385b2e94320057dce7b695f720d703"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#a78385b2e94320057dce7b695f720d703">stoppedCb</a> (std::exception const &amp;e)</td></tr>
<tr class="memdesc:a78385b2e94320057dce7b695f720d703"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback called when this <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is taken out of message dispatching  <a href="#a78385b2e94320057dce7b695f720d703">More...</a><br /></td></tr>
<tr class="separator:a78385b2e94320057dce7b695f720d703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d37734943cba95f1a57536b3d1d49b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ae0d37734943cba95f1a57536b3d1d49b">droppedCb</a> ()</td></tr>
<tr class="memdesc:ae0d37734943cba95f1a57536b3d1d49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback called after the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is safely taken out of the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>  <a href="#ae0d37734943cba95f1a57536b3d1d49b">More...</a><br /></td></tr>
<tr class="separator:ae0d37734943cba95f1a57536b3d1d49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccfe91867a470c8159cf6b5f67c4821"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#a7ccfe91867a470c8159cf6b5f67c4821">invokedCb</a> (size_t dispatched)</td></tr>
<tr class="memdesc:a7ccfe91867a470c8159cf6b5f67c4821"><td class="mdescLeft">&#160;</td><td class="mdescRight">this callback is called all the time (frequently) - the exact timing is after a batch of messages are dispatched. After this call returns, the previously dispatched message's addresses are no longer valid, which means if you cache the event addresses in the previous handleMessageCb()s, you cannot use those after the return of the next invokeCb function.  <a href="#a7ccfe91867a470c8159cf6b5f67c4821">More...</a><br /></td></tr>
<tr class="separator:a7ccfe91867a470c8159cf6b5f67c4821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58a71bea254993fda723e83b7adbe76"><td class="memItemLeft" align="right" valign="top"><a id="ad58a71bea254993fda723e83b7adbe76"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ad58a71bea254993fda723e83b7adbe76">~Client</a> ()</td></tr>
<tr class="memdesc:ad58a71bea254993fda723e83b7adbe76"><td class="mdescLeft">&#160;</td><td class="mdescRight">trivial <br /></td></tr>
<tr class="separator:ad58a71bea254993fda723e83b7adbe76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e562879c6bb4623c6c86f2b1e5b1b3"><td class="memItemLeft" align="right" valign="top"><a id="a03e562879c6bb4623c6c86f2b1e5b1b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#a03e562879c6bb4623c6c86f2b1e5b1b3">stopped</a> (std::exception const &amp;e) noexcept</td></tr>
<tr class="memdesc:a03e562879c6bb4623c6c86f2b1e5b1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the following are for internal use, don't change or override <br /></td></tr>
<tr class="separator:a03e562879c6bb4623c6c86f2b1e5b1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acc50d1e9440a88f0311aee3f95d4305b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#acc50d1e9440a88f0311aee3f95d4305b">batchDone</a> ()</td></tr>
<tr class="memdesc:acc50d1e9440a88f0311aee3f95d4305b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the derived user's <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> has the option to stop the current batch of event dispatching.  <a href="#acc50d1e9440a88f0311aee3f95d4305b">More...</a><br /></td></tr>
<tr class="separator:acc50d1e9440a88f0311aee3f95d4305b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename CcClient, MessageC ... Messages&gt;<br />
class hmbdc::app::Client&lt; CcClient, Messages &gt;</h3>

<p>A <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> represents a thread of execution/a task. The execution is managed by a <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>. a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> object could participate in message dispatching as the receiver of specifed message types. </p>
<p>message is dispatched thru callbacks in the loose form of void handleMessageCb(Message const&amp; m) or void handleMessageCb(Message&amp; m). some callbacks have default implementations. however, all callbacks are overridable to provide desired effects; When running in a <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>, all callbacks (*Cb methods) for a hmbdc <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> instance are garanteed to be called from a single OS thread, ie. no 2 callabacks of an <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> instance are called concurrently, so the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> programmer can assume a single thread programming model callback-wise. The above also holds true for timer firing callbacks when a concrete <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> deriving from TimerManager that manages the timers</p>
<p>See in example hmbdc.cpp </p><div class="fragment"></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CcClient</td><td>the concrete <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> type </td></tr>
    <tr><td class="paramname">typename</td><td>... Messages message types that the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> interested if the type of <a class="el" href="structhmbdc_1_1app_1_1JustBytes.html" title="A special type of message only used on the receiving side. ">JustBytes</a> is declared, use a special callback see below</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handleJustBytesCb(uint16_t tag, uint8_t* bytes, hasMemoryAttachment* att){...}</div></div><!-- fragment --><p> is expected See in example hmbdc.cpp </p><div class="fragment"></div><!-- fragment --></div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acc50d1e9440a88f0311aee3f95d4305b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc50d1e9440a88f0311aee3f95d4305b">&#9670;&nbsp;</a></span>batchDone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcClient, MessageC ... Messages&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client</a>&lt; CcClient, Messages &gt;::batchDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the derived user's <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> has the option to stop the current batch of event dispatching. </p>
<p>for example, if the user's <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> decides it has handled all interested messages and wants to skip the remaining messages within the CURRENT batch, call this within any callback functions. use with caution, only when it is absolutely certain that there is NO messages of ANY type the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> need to care are within the current batch. </p>

</div>
</div>
<a id="ae0d37734943cba95f1a57536b3d1d49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d37734943cba95f1a57536b3d1d49b">&#9670;&nbsp;</a></span>droppedCb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcClient, MessageC ... Messages&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client</a>&lt; CcClient, Messages &gt;::droppedCb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>callback called after the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is safely taken out of the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> </p>
<p>exception thrown here is ignored and return true is assumed </p><dl class="section return"><dt>Returns</dt><dd>if false, this <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is added back to the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> to process messages otherwise, no more callback. You could even safely "delete this; return true;" </dd></dl>

<p>Reimplemented in <a class="el" href="structhmbdc_1_1tips_1_1rmcast_1_1sendtransportengine__detail_1_1SendTransportEngine.html#a0aaa89d83965925cbae79d415b2f3f06">hmbdc::tips::rmcast::sendtransportengine_detail::SendTransportEngine</a>, <a class="el" href="structhmbdc_1_1tips_1_1rnetmap_1_1sendtransportengine__detail_1_1SendTransportEngine.html#ad4fd8cf8e4c6aa7451d6c40bad438871">hmbdc::tips::rnetmap::sendtransportengine_detail::SendTransportEngine</a>, <a class="el" href="structhmbdc_1_1tips_1_1tcpcast_1_1send__detail_1_1SendTransportEngine.html#a63c01b01c567aecb2ecc51ebca626327">hmbdc::tips::tcpcast::send_detail::SendTransportEngine</a>, <a class="el" href="structhmbdc_1_1tips_1_1udpcast_1_1sendtransportengine__detail_1_1SendTransportEngine.html#a422d8510aafc01fcc5a82bff5e3473a1">hmbdc::tips::udpcast::sendtransportengine_detail::SendTransportEngine</a>, and <a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1sendtransportengine__detail_1_1SendTransportEngine.html#a1eddd3c86506d2ea7e5656c4ce745509">hmbdc::tips::netmap::sendtransportengine_detail::SendTransportEngine</a>.</p>

</div>
</div>
<a id="a91448c0e9b4a40c1ab9fa795aa1175b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91448c0e9b4a40c1ab9fa795aa1175b5">&#9670;&nbsp;</a></span>hmbdcName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcClient, MessageC ... Messages&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char const* <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client</a>&lt; CcClient, Messages &gt;::hmbdcName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the name of thread that runs this client, override if necessary </p>
<p>this only used when the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is running in direct mode </p><dl class="section return"><dt>Returns</dt><dd>thread name - default to be hmbdc0, hmbdc1 ... </dd></dl>

</div>
</div>
<a id="a7ccfe91867a470c8159cf6b5f67c4821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccfe91867a470c8159cf6b5f67c4821">&#9670;&nbsp;</a></span>invokedCb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcClient, MessageC ... Messages&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client</a>&lt; CcClient, Messages &gt;::invokedCb </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dispatched</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this callback is called all the time (frequently) - the exact timing is after a batch of messages are dispatched. After this call returns, the previously dispatched message's addresses are no longer valid, which means if you cache the event addresses in the previous handleMessageCb()s, you cannot use those after the return of the next invokeCb function. </p>
<p>you can collectively process the messages received/cached so far here, or do something needs to be done all the time like powering another message loop</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatched</td><td>the number of messages dispatched since last invokedCb called </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="structhmbdc_1_1tips_1_1rmcast_1_1sendtransportengine__detail_1_1SendTransportEngine.html#af13801de54fe8620b8ce70112c76a8b6">hmbdc::tips::rmcast::sendtransportengine_detail::SendTransportEngine</a>, <a class="el" href="structhmbdc_1_1tips_1_1rnetmap_1_1sendtransportengine__detail_1_1SendTransportEngine.html#affc2a1a754187f5976cfc10df442c0dd">hmbdc::tips::rnetmap::sendtransportengine_detail::SendTransportEngine</a>, <a class="el" href="structhmbdc_1_1tips_1_1rmcast_1_1recvtransportengine__detail_1_1RecvTransportEngine.html#a345ee310915cd54ddee5abd75d23b17f">hmbdc::tips::rmcast::recvtransportengine_detail::RecvTransportEngine&lt; OutputBuffer, AttachmentAllocator &gt;</a>, <a class="el" href="structhmbdc_1_1tips_1_1tcpcast_1_1send__detail_1_1SendTransportEngine.html#af18fe51b49a6ad56a96beba2a6e852b8">hmbdc::tips::tcpcast::send_detail::SendTransportEngine</a>, <a class="el" href="structhmbdc_1_1tips_1_1udpcast_1_1recvtransportengine__detail_1_1RecvTransportEngineImpl.html#a14008dbb2be8d37b920db66da288e04e">hmbdc::tips::udpcast::recvtransportengine_detail::RecvTransportEngineImpl&lt; OutputBuffer &gt;</a>, <a class="el" href="structhmbdc_1_1tips_1_1rnetmap_1_1recvtransportengine__detail_1_1RecvTransportEngine.html#a324a465930d611a4c20247f9cc697efe">hmbdc::tips::rnetmap::recvtransportengine_detail::RecvTransportEngine&lt; OutputBuffer, AttachmentAllocator &gt;</a>, <a class="el" href="structhmbdc_1_1tips_1_1udpcast_1_1sendtransportengine__detail_1_1SendTransportEngine.html#a0588b01b55d6f60dae58212c8b490f94">hmbdc::tips::udpcast::sendtransportengine_detail::SendTransportEngine</a>, <a class="el" href="structhmbdc_1_1tips_1_1tcpcast_1_1recvtransportengine__detail_1_1RecvTransportEngine.html#ad5cd51b9b7018a9cf6cc89bc33e3e0f6">hmbdc::tips::tcpcast::recvtransportengine_detail::RecvTransportEngine&lt; OutputBuffer, AttachmentAllocator &gt;</a>, <a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1RecvTransportEngine.html#a6318714c98ab7a075c94fc85116a435b">hmbdc::tips::netmap::RecvTransportEngine&lt; OutBuffer &gt;</a>, <a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1sendtransportengine__detail_1_1SendTransportEngine.html#a757a72d064dcadceb03f406a0ad7d759">hmbdc::tips::netmap::sendtransportengine_detail::SendTransportEngine</a>, and <a class="el" href="structhmbdc_1_1app_1_1StuckClientPurger.html#ab75c88353691c10338ad01da5acb0b5e">hmbdc::app::StuckClientPurger&lt; Buffer &gt;</a>.</p>

</div>
</div>
<a id="ad12b8f43afb684949bec0ac3949724c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12b8f43afb684949bec0ac3949724c8">&#9670;&nbsp;</a></span>maxBatchMessageCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcClient, MessageC ... Messages&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client</a>&lt; CcClient, Messages &gt;::maxBatchMessageCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an overridable method. client receives events in batches and the max batch size is controllable when running in direct mode <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>. Here is to specify the max size. </p>
<p>a message could only be reaching one client when using partition <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>. In this case, reduce the size (reduce the greediness) might be useful </p><dl class="section return"><dt>Returns</dt><dd>the max number of messages when grabbing messages to process </dd></dl>

</div>
</div>
<a id="ab11a96a305f27f829a87c8961ada7829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11a96a305f27f829a87c8961ada7829">&#9670;&nbsp;</a></span>messageDispatchingStartedCb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcClient, MessageC ... Messages&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client</a>&lt; CcClient, Messages &gt;::messageDispatchingStartedCb </td>
          <td>(</td>
          <td class="paramtype">size_t const *&#160;</td>
          <td class="paramname"><em>pClientDispatchingStarted</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>called before any messages got dispatched - only once </p>
<p>this is the place some preparation code goes to</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pClientDispatchingStarted</td><td>pointer to the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> count that has started displatching within its <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>; its value could change if you repeatedly check - might be used to sync with other Clients within the same <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> (particularly IPC <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>) at starting up stage of the system. When doing the sync, just be aware the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> might be running in a pool - do not hog the pool thread if possible. Note: Since ipc_creator <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> has an implicitly purger <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a>, this value would be 1 greater than the user Clients count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe1fe10601c73c7915253982ab7f0f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1fe10601c73c7915253982ab7f0f8b">&#9670;&nbsp;</a></span>schedSpec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcClient, MessageC ... Messages&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;char const*, int&gt; <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client</a>&lt; CcClient, Messages &gt;::schedSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an overrideable method. returns the schedule policy and priority, override if necessary priority is only used when policy is "SCHED_RR", or "SCHED_FIFO" </p>
<p>this is only used when the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is running in direct mode supported policy are "SCHED_OTHER"(=nullptr), "SCHED_RR", "SCHED_FIFO" </p><dl class="section return"><dt>Returns</dt><dd>a tuple made of schedule policy and priority, default to be SCHED_OTHER </dd></dl>

</div>
</div>
<a id="a78385b2e94320057dce7b695f720d703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78385b2e94320057dce7b695f720d703">&#9670;&nbsp;</a></span>stoppedCb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcClient, MessageC ... Messages&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client</a>&lt; CcClient, Messages &gt;::stoppedCb </td>
          <td>(</td>
          <td class="paramtype">std::exception const &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>callback called when this <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is taken out of message dispatching </p>
<p>after this call the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is still at hook from the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> point of view (until droppedCb is called), so don't delete this <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> yet or add it back to the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>. any exception thrown here is ignored,</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exception that caused the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> to be taken out of message dispatching e could be thrown by the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> itself in a callback function to voluntarily take itself out </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="structhmbdc_1_1tips_1_1rnetmap_1_1sendtransportengine__detail_1_1SendTransportEngine.html#a9b5d4c84cb3365fa49f5262f104934aa">hmbdc::tips::rnetmap::sendtransportengine_detail::SendTransportEngine</a>, <a class="el" href="structhmbdc_1_1tips_1_1rmcast_1_1recvtransportengine__detail_1_1RecvTransportEngine.html#afe6a90f0723a6cf970243fa495bc6b52">hmbdc::tips::rmcast::recvtransportengine_detail::RecvTransportEngine&lt; OutputBuffer, AttachmentAllocator &gt;</a>, <a class="el" href="structhmbdc_1_1tips_1_1udpcast_1_1recvtransportengine__detail_1_1RecvTransportEngineImpl.html#a3b02345c1361d52aab5f0fcc89fa0576">hmbdc::tips::udpcast::recvtransportengine_detail::RecvTransportEngineImpl&lt; OutputBuffer &gt;</a>, <a class="el" href="structhmbdc_1_1tips_1_1rnetmap_1_1recvtransportengine__detail_1_1RecvTransportEngine.html#a76ccdd1d663aa609b586c7f428d481b6">hmbdc::tips::rnetmap::recvtransportengine_detail::RecvTransportEngine&lt; OutputBuffer, AttachmentAllocator &gt;</a>, <a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1RecvTransportEngine.html#ab4a53ec8663c5f1551c7ab7d67554f54">hmbdc::tips::netmap::RecvTransportEngine&lt; OutBuffer &gt;</a>, <a class="el" href="structhmbdc_1_1tips_1_1tcpcast_1_1recvtransportengine__detail_1_1RecvTransportEngine.html#a1ebe274a900dd38d3ecbb3ad3e0eb416">hmbdc::tips::tcpcast::recvtransportengine_detail::RecvTransportEngine&lt; OutputBuffer, AttachmentAllocator &gt;</a>, <a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1sendtransportengine__detail_1_1SendTransportEngine.html#a4c8454a306e395dc7c4fa10a9cf8bf0f">hmbdc::tips::netmap::sendtransportengine_detail::SendTransportEngine</a>, and <a class="el" href="structhmbdc_1_1app_1_1StuckClientPurger.html#a9b40e2eaffc1310c1d349e64ca4b2235">hmbdc::app::StuckClientPurger&lt; Buffer &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hmbdc/app/<a class="el" href="Client_8hpp_source.html">Client.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
