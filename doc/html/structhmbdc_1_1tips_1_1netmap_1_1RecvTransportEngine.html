<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hmbdc: hmbdc::tips::netmap::RecvTransportEngine&lt; OutBuffer &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hmbdc
   </div>
   <div id="projectbrief">simplify-high-performance-messaging-programming</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehmbdc.html">hmbdc</a></li><li class="navelem"><b>tips</b></li><li class="navelem"><b>netmap</b></li><li class="navelem"><a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1RecvTransportEngine.html">RecvTransportEngine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="structhmbdc_1_1tips_1_1netmap_1_1RecvTransportEngine-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hmbdc::tips::netmap::RecvTransportEngine&lt; OutBuffer &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for hmbdc::tips::netmap::RecvTransportEngine&lt; OutBuffer &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structhmbdc_1_1tips_1_1netmap_1_1RecvTransportEngine.png" usemap="#hmbdc::tips::netmap::RecvTransportEngine_3C_20OutBuffer_20_3E_map" alt=""/>
  <map id="hmbdc::tips::netmap::RecvTransportEngine_3C_20OutBuffer_20_3E_map" name="hmbdc::tips::netmap::RecvTransportEngine_3C_20OutBuffer_20_3E_map">
<area href="structhmbdc_1_1app_1_1Client.html" alt="hmbdc::app::Client&lt; RecvTransportEngine&lt; OutBuffer &gt; &gt;" shape="rect" coords="0,0,339,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6318714c98ab7a075c94fc85116a435b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1RecvTransportEngine.html#a6318714c98ab7a075c94fc85116a435b">invokedCb</a> (size_t) HMBDC_RESTRICT override</td></tr>
<tr class="memdesc:a6318714c98ab7a075c94fc85116a435b"><td class="mdescLeft">&#160;</td><td class="mdescRight">this callback is called all the time (frequently) - the exact timing is after a batch of messages are dispatched. After this call returns, the previously dispatched message's addresses are no longer valid, which means if you cache the event addresses in the previous handleMessageCb()s, you cannot use those after the return of the next invokeCb function.  <a href="#a6318714c98ab7a075c94fc85116a435b">More...</a><br /></td></tr>
<tr class="separator:a6318714c98ab7a075c94fc85116a435b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a53ec8663c5f1551c7ab7d67554f54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1RecvTransportEngine.html#ab4a53ec8663c5f1551c7ab7d67554f54">stoppedCb</a> (std::exception const &amp;e) override</td></tr>
<tr class="memdesc:ab4a53ec8663c5f1551c7ab7d67554f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback called when this Client is taken out of message dispatching  <a href="#ab4a53ec8663c5f1551c7ab7d67554f54">More...</a><br /></td></tr>
<tr class="separator:ab4a53ec8663c5f1551c7ab7d67554f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structhmbdc_1_1app_1_1Client"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structhmbdc_1_1app_1_1Client')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client&lt; RecvTransportEngine&lt; OutBuffer &gt; &gt;</a></td></tr>
<tr class="memitem:a91448c0e9b4a40c1ab9fa795aa1175b5 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#a91448c0e9b4a40c1ab9fa795aa1175b5">hmbdcName</a> () const</td></tr>
<tr class="memdesc:a91448c0e9b4a40c1ab9fa795aa1175b5 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the name of thread that runs this client, override if necessary  <a href="structhmbdc_1_1app_1_1Client.html#a91448c0e9b4a40c1ab9fa795aa1175b5">More...</a><br /></td></tr>
<tr class="separator:a91448c0e9b4a40c1ab9fa795aa1175b5 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1fe10601c73c7915253982ab7f0f8b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; char const *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#abe1fe10601c73c7915253982ab7f0f8b">schedSpec</a> () const</td></tr>
<tr class="memdesc:abe1fe10601c73c7915253982ab7f0f8b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">an overrideable method. returns the schedule policy and priority, override if necessary priority is only used when policy is "SCHED_RR", or "SCHED_FIFO"  <a href="structhmbdc_1_1app_1_1Client.html#abe1fe10601c73c7915253982ab7f0f8b">More...</a><br /></td></tr>
<tr class="separator:abe1fe10601c73c7915253982ab7f0f8b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12b8f43afb684949bec0ac3949724c8 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ad12b8f43afb684949bec0ac3949724c8">maxBatchMessageCount</a> () const</td></tr>
<tr class="memdesc:ad12b8f43afb684949bec0ac3949724c8 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">an overridable method. client receives events in batches and the max batch size is controllable when running in direct mode Context. Here is to specify the max size.  <a href="structhmbdc_1_1app_1_1Client.html#ad12b8f43afb684949bec0ac3949724c8">More...</a><br /></td></tr>
<tr class="separator:ad12b8f43afb684949bec0ac3949724c8 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11a96a305f27f829a87c8961ada7829 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ab11a96a305f27f829a87c8961ada7829">messageDispatchingStartedCb</a> (size_t const *pClientDispatchingStarted)</td></tr>
<tr class="memdesc:ab11a96a305f27f829a87c8961ada7829 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">called before any messages got dispatched - only once  <a href="structhmbdc_1_1app_1_1Client.html#ab11a96a305f27f829a87c8961ada7829">More...</a><br /></td></tr>
<tr class="separator:ab11a96a305f27f829a87c8961ada7829 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d37734943cba95f1a57536b3d1d49b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ae0d37734943cba95f1a57536b3d1d49b">droppedCb</a> ()</td></tr>
<tr class="memdesc:ae0d37734943cba95f1a57536b3d1d49b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback called after the Client is safely taken out of the Context  <a href="structhmbdc_1_1app_1_1Client.html#ae0d37734943cba95f1a57536b3d1d49b">More...</a><br /></td></tr>
<tr class="separator:ae0d37734943cba95f1a57536b3d1d49b inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ce5546d718168f2df7e7c05502a108 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top"><a id="ad7ce5546d718168f2df7e7c05502a108"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#ad7ce5546d718168f2df7e7c05502a108">Client</a> ()=default</td></tr>
<tr class="memdesc:ad7ce5546d718168f2df7e7c05502a108 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">trivial <br /></td></tr>
<tr class="separator:ad7ce5546d718168f2df7e7c05502a108 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e562879c6bb4623c6c86f2b1e5b1b3 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top"><a id="a03e562879c6bb4623c6c86f2b1e5b1b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#a03e562879c6bb4623c6c86f2b1e5b1b3">stopped</a> (std::exception const &amp;e) noexcept</td></tr>
<tr class="memdesc:a03e562879c6bb4623c6c86f2b1e5b1b3 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">the following are for internal use, don't change or override <br /></td></tr>
<tr class="separator:a03e562879c6bb4623c6c86f2b1e5b1b3 inherit pub_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8a11c0613641c3ee133b3262b12b7689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1RecvTransportEngine.html#a8a11c0613641c3ee133b3262b12b7689">syncNetmap</a> () HMBDC_RESTRICT</td></tr>
<tr class="memdesc:a8a11c0613641c3ee133b3262b12b7689"><td class="mdescLeft">&#160;</td><td class="mdescRight">sync using busy wait or poll depending on config  <a href="#a8a11c0613641c3ee133b3262b12b7689">More...</a><br /></td></tr>
<tr class="separator:a8a11c0613641c3ee133b3262b12b7689"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_structhmbdc_1_1app_1_1Client"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_structhmbdc_1_1app_1_1Client')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="structhmbdc_1_1app_1_1Client.html">hmbdc::app::Client&lt; RecvTransportEngine&lt; OutBuffer &gt; &gt;</a></td></tr>
<tr class="memitem:acc50d1e9440a88f0311aee3f95d4305b inherit pro_methods_structhmbdc_1_1app_1_1Client"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Client.html#acc50d1e9440a88f0311aee3f95d4305b">batchDone</a> ()</td></tr>
<tr class="memdesc:acc50d1e9440a88f0311aee3f95d4305b inherit pro_methods_structhmbdc_1_1app_1_1Client"><td class="mdescLeft">&#160;</td><td class="mdescRight">the derived user's Client has the option to stop the current batch of event dispatching.  <a href="structhmbdc_1_1app_1_1Client.html#acc50d1e9440a88f0311aee3f95d4305b">More...</a><br /></td></tr>
<tr class="separator:acc50d1e9440a88f0311aee3f95d4305b inherit pro_methods_structhmbdc_1_1app_1_1Client"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6318714c98ab7a075c94fc85116a435b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6318714c98ab7a075c94fc85116a435b">&#9670;&nbsp;</a></span>invokedCb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1RecvTransportEngine.html">hmbdc::tips::netmap::RecvTransportEngine</a>&lt; OutBuffer &gt;::invokedCb </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dispatched</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this callback is called all the time (frequently) - the exact timing is after a batch of messages are dispatched. After this call returns, the previously dispatched message's addresses are no longer valid, which means if you cache the event addresses in the previous handleMessageCb()s, you cannot use those after the return of the next invokeCb function. </p>
<p>you can collectively process the messages received/cached so far here, or do something needs to be done all the time like powering another message loop</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatched</td><td>the number of messages dispatched since last invokedCb called </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="structhmbdc_1_1app_1_1Client.html#a7ccfe91867a470c8159cf6b5f67c4821">hmbdc::app::Client&lt; RecvTransportEngine&lt; OutBuffer &gt; &gt;</a>.</p>

</div>
</div>
<a id="ab4a53ec8663c5f1551c7ab7d67554f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a53ec8663c5f1551c7ab7d67554f54">&#9670;&nbsp;</a></span>stoppedCb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1RecvTransportEngine.html">hmbdc::tips::netmap::RecvTransportEngine</a>&lt; OutBuffer &gt;::stoppedCb </td>
          <td>(</td>
          <td class="paramtype">std::exception const &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>callback called when this Client is taken out of message dispatching </p>
<p>after this call the Client is still at hook from the Context point of view (until droppedCb is called), so don't delete this Client yet or add it back to the Context. any exception thrown here is ignored,</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exception that caused the Client to be taken out of message dispatching e could be thrown by the Client itself in a callback function to voluntarily take itself out </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="structhmbdc_1_1app_1_1Client.html#a78385b2e94320057dce7b695f720d703">hmbdc::app::Client&lt; RecvTransportEngine&lt; OutBuffer &gt; &gt;</a>.</p>

</div>
</div>
<a id="a8a11c0613641c3ee133b3262b12b7689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a11c0613641c3ee133b3262b12b7689">&#9670;&nbsp;</a></span>syncNetmap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1netmap_1_1RecvTransportEngine.html">hmbdc::tips::netmap::RecvTransportEngine</a>&lt; OutBuffer &gt;::syncNetmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sync using busy wait or poll depending on config </p>
<p>it turns out busy wait performance is very poor when using vale poll works mostly, but it works well only when an enough timeout is given less than 10 milli wont work well </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>hmbdc/tips/netmap/<a class="el" href="netmap_2RecvTransportEngine_8hpp_source.html">RecvTransportEngine.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
