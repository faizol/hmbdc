<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hmbdc: hmbdc::tips::Node&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hmbdc
   </div>
   <div id="projectbrief">simplify-high-performance-messaging-programming</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehmbdc.html">hmbdc</a></li><li class="navelem"><b>tips</b></li><li class="navelem"><a class="el" href="structhmbdc_1_1tips_1_1Node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structhmbdc_1_1tips_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hmbdc::tips::Node&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>a <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is a thread of execution that can suscribe and receive Messages  
 <a href="structhmbdc_1_1tips_1_1Node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Node_8hpp_source.html">Node.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae47a705256040d83712b2c2ca89d8ad2"><td class="memItemLeft" align="right" valign="top"><a id="ae47a705256040d83712b2c2ca89d8ad2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#ae47a705256040d83712b2c2ca89d8ad2">Interests</a> = RecvMessageTupleIn</td></tr>
<tr class="memdesc:ae47a705256040d83712b2c2ca89d8ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> needs to specify a list of Messages that would be sent out if this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is active to help IPC and network delivering filtering. If not fully specified the message could be invisible outside of this process. <br /></td></tr>
<tr class="separator:ae47a705256040d83712b2c2ca89d8ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d624e6635c73f399542dda44933080c"><td class="memItemLeft" align="right" valign="top">char const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#a9d624e6635c73f399542dda44933080c">hmbdcName</a> () const</td></tr>
<tr class="memdesc:a9d624e6635c73f399542dda44933080c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the thread name used to identify the thread the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is running on  <a href="#a9d624e6635c73f399542dda44933080c">More...</a><br /></td></tr>
<tr class="separator:a9d624e6635c73f399542dda44933080c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f90ad0a28c0c1a4c7383f595f45f125"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#a4f90ad0a28c0c1a4c7383f595f45f125">maxMessageSize</a> () const</td></tr>
<tr class="memdesc:a4f90ad0a28c0c1a4c7383f595f45f125"><td class="mdescLeft">&#160;</td><td class="mdescRight">unless JustBytes is used in <a class="el" href="classInterests.html" title="a std tuple holding messages types it can dispatch ">Interests</a> - this is automatic  <a href="#a4f90ad0a28c0c1a4c7383f595f45f125">More...</a><br /></td></tr>
<tr class="separator:a4f90ad0a28c0c1a4c7383f595f45f125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa1db439d4e9a90e812c0fc737da39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#a21aa1db439d4e9a90e812c0fc737da39">addJustBytesSubsForCfg</a> (std::function&lt; void(uint16_t)&gt; addTag) const</td></tr>
<tr class="memdesc:a21aa1db439d4e9a90e812c0fc737da39"><td class="mdescLeft">&#160;</td><td class="mdescRight">What tags are going to published when JustBytes is in the RecvMessageTuple.  <a href="#a21aa1db439d4e9a90e812c0fc737da39">More...</a><br /></td></tr>
<tr class="separator:a21aa1db439d4e9a90e812c0fc737da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab238e2034463edf4592b91b9c4d22537"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#ab238e2034463edf4592b91b9c4d22537">addJustBytesPubsForCfg</a> (std::function&lt; void(uint16_t)&gt; addTag) const</td></tr>
<tr class="memdesc:ab238e2034463edf4592b91b9c4d22537"><td class="mdescLeft">&#160;</td><td class="mdescRight">What tags are going to published when JustBytes is in the SendMessageTuple.  <a href="#ab238e2034463edf4592b91b9c4d22537">More...</a><br /></td></tr>
<tr class="separator:ab238e2034463edf4592b91b9c4d22537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3141ab20223ef72e00002d5d1ebe8b4c"><td class="memTemplParams" colspan="2">template&lt;app::MessageC Message&gt; </td></tr>
<tr class="memitem:a3141ab20223ef72e00002d5d1ebe8b4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#a3141ab20223ef72e00002d5d1ebe8b4c">addTypeTagRangeSubsForCfg</a> (Message *, std::function&lt; void(uint16_t)&gt; addOffsetInRange) const</td></tr>
<tr class="memdesc:a3141ab20223ef72e00002d5d1ebe8b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concrete node overrides this function for each inTagRange type of Message to indicate which type tags in the range this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> subscribes for - otherwise each one in range is subscribed.  <a href="#a3141ab20223ef72e00002d5d1ebe8b4c">More...</a><br /></td></tr>
<tr class="separator:a3141ab20223ef72e00002d5d1ebe8b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5ee5f33d5934f23c602a897d12a192"><td class="memTemplParams" colspan="2">template&lt;app::MessageC Message&gt; </td></tr>
<tr class="memitem:afc5ee5f33d5934f23c602a897d12a192"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#afc5ee5f33d5934f23c602a897d12a192">addTypeTagRangePubsForCfg</a> (Message *, std::function&lt; void(uint16_t)&gt; addOffsetInRange) const</td></tr>
<tr class="memdesc:afc5ee5f33d5934f23c602a897d12a192"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concrete node overrides this function for each inTagRange type of Message to indicate which type tags in the range this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> subscribes for - otherwise each one in range is expected to be published.  <a href="#afc5ee5f33d5934f23c602a897d12a192">More...</a><br /></td></tr>
<tr class="separator:afc5ee5f33d5934f23c602a897d12a192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b108914951c43d7876ff0e167213ab"><td class="memItemLeft" align="right" valign="top"><a id="aa3b108914951c43d7876ff0e167213ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#aa3b108914951c43d7876ff0e167213ab">updateSubscription</a> ()</td></tr>
<tr class="memdesc:aa3b108914951c43d7876ff0e167213ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> calls this first before handles the subscritions for this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a>. <br /></td></tr>
<tr class="separator:aa3b108914951c43d7876ff0e167213ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5f4ec9c89e0286c2a28c480a275d06"><td class="memTemplParams" colspan="2">template&lt;app::MessageC Message&gt; </td></tr>
<tr class="memitem:a2e5f4ec9c89e0286c2a28c480a275d06"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#a2e5f4ec9c89e0286c2a28c480a275d06">ifDeliverCfg</a> (Message const &amp;message) const</td></tr>
<tr class="memdesc:a2e5f4ec9c89e0286c2a28c480a275d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">an overridable method in the concrete <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> that determine if a message should be deliverred to this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> instance This is called at the sending part before the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is unblocked due to this delivery  <a href="#a2e5f4ec9c89e0286c2a28c480a275d06">More...</a><br /></td></tr>
<tr class="separator:a2e5f4ec9c89e0286c2a28c480a275d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe83ad7955b70c492f984141cecf312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#a9fe83ad7955b70c492f984141cecf312">ifDeliverCfg</a> (uint16_t tag, uint8_t const *bytes) const</td></tr>
<tr class="memdesc:a9fe83ad7955b70c492f984141cecf312"><td class="mdescLeft">&#160;</td><td class="mdescRight">an overridable method in the concrete <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> that determine if a message should be deliverred to this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> instance's JustBytes <a class="el" href="classInterests.html" title="a std tuple holding messages types it can dispatch ">Interests</a> This is called at the sending part before the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is unblocked due to this delivery  <a href="#a9fe83ad7955b70c492f984141cecf312">More...</a><br /></td></tr>
<tr class="separator:a9fe83ad7955b70c492f984141cecf312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cb6b90a31057b451d5c58cee4ad354"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#ac9cb6b90a31057b451d5c58cee4ad354">invokedCb</a> (size_t dispatched)</td></tr>
<tr class="memdesc:ac9cb6b90a31057b451d5c58cee4ad354"><td class="mdescLeft">&#160;</td><td class="mdescRight">this callback is called all the time (frequently) - the exact timing is after a batch of messages are dispatched. After this call returns, the previously dispatched message's addresses are no longer valid, which means if you cache the event addresses in the previous handleMessageCb()s, you cannot use those after the return of the next invokeCb function.  <a href="#ac9cb6b90a31057b451d5c58cee4ad354">More...</a><br /></td></tr>
<tr class="separator:ac9cb6b90a31057b451d5c58cee4ad354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabddbfec69ee84273b1a3c4234bf0426"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#aabddbfec69ee84273b1a3c4234bf0426">resetPubSub</a> ()</td></tr>
<tr class="memdesc:aabddbfec69ee84273b1a3c4234bf0426"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the pub sub registration  <a href="#aabddbfec69ee84273b1a3c4234bf0426">More...</a><br /></td></tr>
<tr class="separator:aabddbfec69ee84273b1a3c4234bf0426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe8d41969deeb5012f464916169ae24"><td class="memTemplParams" colspan="2">template&lt;app::MessageC Message&gt; </td></tr>
<tr class="memitem:aebe8d41969deeb5012f464916169ae24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#aebe8d41969deeb5012f464916169ae24">publish</a> (Message &amp;&amp;message)</td></tr>
<tr class="memdesc:aebe8d41969deeb5012f464916169ae24"><td class="mdescLeft">&#160;</td><td class="mdescRight">publish a message in the <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> that start (own) this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a>  <a href="#aebe8d41969deeb5012f464916169ae24">More...</a><br /></td></tr>
<tr class="separator:aebe8d41969deeb5012f464916169ae24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eabaa589549f3b945cfb8296b6cce74"><td class="memTemplParams" colspan="2">template&lt;app::MessageC Message&gt; </td></tr>
<tr class="memitem:a7eabaa589549f3b945cfb8296b6cce74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#a7eabaa589549f3b945cfb8296b6cce74">tryPublish</a> (Message &amp;&amp;message)</td></tr>
<tr class="memdesc:a7eabaa589549f3b945cfb8296b6cce74"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to publish a message in the <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> that start (own) this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a>  <a href="#a7eabaa589549f3b945cfb8296b6cce74">More...</a><br /></td></tr>
<tr class="separator:a7eabaa589549f3b945cfb8296b6cce74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11242cdd2cc5a17deef86dcca4accf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#aa11242cdd2cc5a17deef86dcca4accf2">publishJustBytes</a> (uint16_t tag, void const *bytes, size_t len, <a class="el" href="structhmbdc_1_1app_1_1hasMemoryAttachment.html">app::hasMemoryAttachment</a> *att)</td></tr>
<tr class="memdesc:aa11242cdd2cc5a17deef86dcca4accf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">publish a message in the <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> that start (own) this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a>  <a href="#aa11242cdd2cc5a17deef86dcca4accf2">More...</a><br /></td></tr>
<tr class="separator:aa11242cdd2cc5a17deef86dcca4accf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e63609ee3647b97db0c05cb4c981c80"><td class="memTemplParams" colspan="2">template&lt;app::MessageC Message, typename T , typename ... Args&gt; </td></tr>
<tr class="memitem:a7e63609ee3647b97db0c05cb4c981c80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1tips_1_1Node.html#a7e63609ee3647b97db0c05cb4c981c80">allocateInShmFor0cpy</a> (<a class="el" href="structhmbdc_1_1tips_1_1hasSharedPtrAttachment.html">hasSharedPtrAttachment</a>&lt; Message, T, true &gt; &amp;att, size_t actualSize, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a7e63609ee3647b97db0c05cb4c981c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate in shm for a <a class="el" href="structhmbdc_1_1tips_1_1hasSharedPtrAttachment.html" title="Message that need to be IPCed and/or go through Network can derived from this type if it holds 1 (and...">hasSharedPtrAttachment</a> to be published later The release of it is auto handled in TIPS Note: the node needs to be already added to a <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> to be able to call this Will block if the shm is out of mem throw exception if shm is not supported  <a href="#a7e63609ee3647b97db0c05cb4c981c80">More...</a><br /></td></tr>
<tr class="separator:a7e63609ee3647b97db0c05cb4c981c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename CcNode, app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt;<br />
struct hmbdc::tips::Node&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;</h3>

<p>a <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is a thread of execution that can suscribe and receive Messages </p>
<p>There are two categories of callback functions "Cb" and "Cfg" and they are called from different threads. All messages are received through "Cb" callback functions. All "Cb"callback functions are called in this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a>'s thread sequentially, so there is no data protection needs within a <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> from this perspective. The framework uses "Cfg" callback functions mostly at the initialization stage to set up pub/sub configurations before message dispatching </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CcNode</td><td>The concrete <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> type </td></tr>
    <tr><td class="paramname">RecvMessageTuple</td><td>The std tuple list all the received Message types. The matching handleMessageCb for the above type needs to be provided for each type so this message is handled - othewise cannot not compile. For example: void handleMessageCb(MessageA const&amp; m){...} </td></tr>
    <tr><td class="paramname">HasMessageStash</td><td>- if the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> needs Message reorderring support See <a class="el" href="ClientWithStash_8hpp_source.html">ClientWithStash.hpp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="hello-world_8cpp-example.html#_a1">hello-world.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab238e2034463edf4592b91b9c4d22537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab238e2034463edf4592b91b9c4d22537">&#9670;&nbsp;</a></span>addJustBytesPubsForCfg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::addJustBytesPubsForCfg </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(uint16_t)&gt;&#160;</td>
          <td class="paramname"><em>addTag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What tags are going to published when JustBytes is in the SendMessageTuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addTag</td><td>functor used to addd a tag value (NOT tag offset) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21aa1db439d4e9a90e812c0fc737da39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aa1db439d4e9a90e812c0fc737da39">&#9670;&nbsp;</a></span>addJustBytesSubsForCfg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::addJustBytesSubsForCfg </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(uint16_t)&gt;&#160;</td>
          <td class="paramname"><em>addTag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What tags are going to published when JustBytes is in the RecvMessageTuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addTag</td><td>functor used to addd a tag value (NOT tag offset) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc5ee5f33d5934f23c602a897d12a192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5ee5f33d5934f23c602a897d12a192">&#9670;&nbsp;</a></span>addTypeTagRangePubsForCfg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<div class="memtemplate">
template&lt;app::MessageC Message&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::addTypeTagRangePubsForCfg </td>
          <td>(</td>
          <td class="paramtype">Message *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(uint16_t)&gt;&#160;</td>
          <td class="paramname"><em>addOffsetInRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The concrete node overrides this function for each inTagRange type of Message to indicate which type tags in the range this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> subscribes for - otherwise each one in range is expected to be published. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>the inTagRange Message </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addOffsetInRange</td><td>a functor that adds a type tag into the subscription Note - the functor does not take a type tag - instead it takes the tag offset within the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3141ab20223ef72e00002d5d1ebe8b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3141ab20223ef72e00002d5d1ebe8b4c">&#9670;&nbsp;</a></span>addTypeTagRangeSubsForCfg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<div class="memtemplate">
template&lt;app::MessageC Message&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::addTypeTagRangeSubsForCfg </td>
          <td>(</td>
          <td class="paramtype">Message *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(uint16_t)&gt;&#160;</td>
          <td class="paramname"><em>addOffsetInRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The concrete node overrides this function for each inTagRange type of Message to indicate which type tags in the range this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> subscribes for - otherwise each one in range is subscribed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>the inTagRange Message </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addOffsetInRange</td><td>a functor that adds a type tag into the subscription Note - the functor does not take a type tag - instead it takes the tag offset within the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e63609ee3647b97db0c05cb4c981c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e63609ee3647b97db0c05cb4c981c80">&#9670;&nbsp;</a></span>allocateInShmFor0cpy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<div class="memtemplate">
template&lt;app::MessageC Message, typename T , typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::allocateInShmFor0cpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1tips_1_1hasSharedPtrAttachment.html">hasSharedPtrAttachment</a>&lt; Message, T, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>att</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>actualSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocate in shm for a <a class="el" href="structhmbdc_1_1tips_1_1hasSharedPtrAttachment.html" title="Message that need to be IPCed and/or go through Network can derived from this type if it holds 1 (and...">hasSharedPtrAttachment</a> to be published later The release of it is auto handled in TIPS Note: the node needs to be already added to a <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> to be able to call this Will block if the shm is out of mem throw exception if shm is not supported </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td><a class="el" href="structhmbdc_1_1tips_1_1hasSharedPtrAttachment.html" title="Message that need to be IPCed and/or go through Network can derived from this type if it holds 1 (and...">hasSharedPtrAttachment</a> tparam </td></tr>
    <tr><td class="paramname">T</td><td><a class="el" href="structhmbdc_1_1tips_1_1hasSharedPtrAttachment.html" title="Message that need to be IPCed and/or go through Network can derived from this type if it holds 1 (and...">hasSharedPtrAttachment</a> tparam - it needs to be trivial destructable </td></tr>
    <tr><td class="paramname">Args</td><td>args for T's ctor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">att</td><td>the message holds the shared memory </td></tr>
    <tr><td class="paramname">actualSize</td><td>T's actual size in bytes - could be &gt; sizeof(T) for open ended struct </td></tr>
    <tr><td class="paramname">args</td><td>args for T's ctor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d624e6635c73f399542dda44933080c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d624e6635c73f399542dda44933080c">&#9670;&nbsp;</a></span>hmbdcName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char const* <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::hmbdcName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the thread name used to identify the thread the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is running on </p>
<ul>
<li>only for display purpose</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>char const* a string - less than 8 char typically </dd></dl>

</div>
</div>
<a id="a2e5f4ec9c89e0286c2a28c480a275d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5f4ec9c89e0286c2a28c480a275d06">&#9670;&nbsp;</a></span>ifDeliverCfg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<div class="memtemplate">
template&lt;app::MessageC Message&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::ifDeliverCfg </td>
          <td>(</td>
          <td class="paramtype">Message const &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an overridable method in the concrete <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> that determine if a message should be deliverred to this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> instance This is called at the sending part before the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is unblocked due to this delivery </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>decision is for this Message type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The decision on this Message instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if proceed to deliever it </dd>
<dd>
false if not </dd></dl>

</div>
</div>
<a id="a9fe83ad7955b70c492f984141cecf312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe83ad7955b70c492f984141cecf312">&#9670;&nbsp;</a></span>ifDeliverCfg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::ifDeliverCfg </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an overridable method in the concrete <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> that determine if a message should be deliverred to this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> instance's JustBytes <a class="el" href="classInterests.html" title="a std tuple holding messages types it can dispatch ">Interests</a> This is called at the sending part before the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is unblocked due to this delivery </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>decision is for this Message type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>message tag </td></tr>
    <tr><td class="paramname">bytes</td><td>message address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if proceed to deliever it </dd>
<dd>
false if not </dd></dl>

</div>
</div>
<a id="ac9cb6b90a31057b451d5c58cee4ad354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cb6b90a31057b451d5c58cee4ad354">&#9670;&nbsp;</a></span>invokedCb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::invokedCb </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dispatched</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this callback is called all the time (frequently) - the exact timing is after a batch of messages are dispatched. After this call returns, the previously dispatched message's addresses are no longer valid, which means if you cache the event addresses in the previous handleMessageCb()s, you cannot use those after the return of the next invokeCb function. </p>
<p>you can collectively process the messages received/cached so far here, or do something needs to be done all the time like powering another message loop</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatched</td><td>the number of messages dispatched since last invokedCb called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f90ad0a28c0c1a4c7383f595f45f125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f90ad0a28c0c1a4c7383f595f45f125">&#9670;&nbsp;</a></span>maxMessageSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::maxMessageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unless JustBytes is used in <a class="el" href="classInterests.html" title="a std tuple holding messages types it can dispatch ">Interests</a> - this is automatic </p>
<dl class="section return"><dt>Returns</dt><dd>size_t what is the biggest message this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is to receive </dd></dl>

</div>
</div>
<a id="aebe8d41969deeb5012f464916169ae24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe8d41969deeb5012f464916169ae24">&#9670;&nbsp;</a></span>publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<div class="memtemplate">
template&lt;app::MessageC Message&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::publish </td>
          <td>(</td>
          <td class="paramtype">Message &amp;&amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>publish a message in the <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> that start (own) this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> </p>
<p>see <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> publish </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>TIPS message type with tag &gt; 1000 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa11242cdd2cc5a17deef86dcca4accf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11242cdd2cc5a17deef86dcca4accf2">&#9670;&nbsp;</a></span>publishJustBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::publishJustBytes </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1app_1_1hasMemoryAttachment.html">app::hasMemoryAttachment</a> *&#160;</td>
          <td class="paramname"><em>att</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>publish a message in the <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> that start (own) this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> </p>
<p>see <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> publish </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>message tag </td></tr>
    <tr><td class="paramname">bytes</td><td>message bytes </td></tr>
    <tr><td class="paramname">len</td><td>message len of the above bytes </td></tr>
    <tr><td class="paramname">att</td><td>attachment ptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabddbfec69ee84273b1a3c4234bf0426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabddbfec69ee84273b1a3c4234bf0426">&#9670;&nbsp;</a></span>resetPubSub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::resetPubSub </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset the pub sub registration </p>
<p>can only be called after the <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> is added into a <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> </p>
<p>can only add right now </p>

</div>
</div>
<a id="a7eabaa589549f3b945cfb8296b6cce74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eabaa589549f3b945cfb8296b6cce74">&#9670;&nbsp;</a></span>tryPublish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CcNode , app::MessageTupleC RecvMessageTupleIn, app::MessageTupleC SendMessageTupleIn = std::tuple&lt;&gt;, bool HasMessageStashIn = false&gt; </div>
<div class="memtemplate">
template&lt;app::MessageC Message&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1tips_1_1Node.html">hmbdc::tips::Node</a>&lt; CcNode, RecvMessageTupleIn, SendMessageTupleIn, HasMessageStashIn &gt;::tryPublish </td>
          <td>(</td>
          <td class="paramtype">Message &amp;&amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>try to publish a message in the <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> that start (own) this <a class="el" href="structhmbdc_1_1tips_1_1Node.html" title="a Node is a thread of execution that can suscribe and receive Messages ">Node</a> </p>
<p>see <a class="el" href="structhmbdc_1_1tips_1_1Domain.html" title="Messages published on a TIPS pub/sub domain reach all the Nodes within that domain based on their sub...">Domain</a> tryPublish </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message</td><td>TIPS message type with tag &gt; 1000 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>hmbdc/tips/<a class="el" href="Node_8hpp_source.html">Node.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
