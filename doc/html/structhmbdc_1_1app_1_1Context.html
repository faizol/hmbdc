<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hmbdc: hmbdc::app::Context&lt; MaxMessageSize, ContextProperties &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hmbdc
   </div>
   <div id="projectbrief">simplify-high-performance-messaging-programming</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hmbdc</b></li><li class="navelem"><a class="el" href="namespacehmbdc_1_1app.html">app</a></li><li class="navelem"><a class="el" href="structhmbdc_1_1app_1_1Context.html">Context</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="structhmbdc_1_1app_1_1Context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hmbdc::app::Context&lt; MaxMessageSize, ContextProperties &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> is like a media object that facilitates the communications for the Clients that it is holding. a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> can only be added to (or started within) once to a single <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>, undefined behavior otherwise. the communication model is determined by the <a class="el" href="namespacehmbdc_1_1app_1_1context__property.html">context_property</a> by default it is in the nature of broadcast fashion within local process indicating by broadcast&lt;&gt;  
 <a href="structhmbdc_1_1app_1_1Context.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Context_8hpp_source.html">Context.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for hmbdc::app::Context&lt; MaxMessageSize, ContextProperties &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structhmbdc_1_1app_1_1Context.png" usemap="#hmbdc::app::Context_3C_20MaxMessageSize_2C_20ContextProperties_20_3E_map" alt=""/>
  <map id="hmbdc::app::Context_3C_20MaxMessageSize_2C_20ContextProperties_20_3E_map" name="hmbdc::app::Context_3C_20MaxMessageSize_2C_20ContextProperties_20_3E_map">
<area href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html" alt="hmbdc::app::context_detail::ThreadCommBase&lt; MaxMessageSize, ContextProperties... &gt;" shape="rect" coords="0,56,511,80"/>
<area href="structhmbdc_1_1app_1_1context__detail_1_1context__property__aggregator.html" alt="hmbdc::app::context_detail::context_property_aggregator&lt; ContextProperties... &gt;" shape="rect" coords="0,0,511,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae217f2ebfa79ca2f5614d29a3d30d157"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#ae217f2ebfa79ca2f5614d29a3d30d157">Context</a> (uint32_t messageQueueSizePower2Num=MaxMessageSize?20:2, size_t maxPoolClientCount=MaxMessageSize?128:0, size_t maxMessageSizeRuntime=MaxMessageSize)</td></tr>
<tr class="memdesc:ae217f2ebfa79ca2f5614d29a3d30d157"><td class="mdescLeft">&#160;</td><td class="mdescRight">ctor for construct local non-ipc <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>  <a href="#ae217f2ebfa79ca2f5614d29a3d30d157">More...</a><br /></td></tr>
<tr class="separator:ae217f2ebfa79ca2f5614d29a3d30d157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ef0505cc8cdf7d326b70845057b7c4"><td class="memTemplParams" colspan="2">template&lt;typename IntRvOrLv , std::enable_if_t&lt; std::is_same&lt; int, typename std::decay&lt; IntRvOrLv &gt;::type &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a65ef0505cc8cdf7d326b70845057b7c4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#a65ef0505cc8cdf7d326b70845057b7c4">Context</a> (IntRvOrLv &amp;&amp;ownership, char const *ipcTransportName, uint32_t messageQueueSizePower2Num=MaxMessageSize?20:0, size_t maxPoolClientCount=MaxMessageSize?128:0, size_t maxMessageSizeRuntime=MaxMessageSize, uint64_t purgerCpuAffinityMask=0xfffffffffffffffful, size_t ipcTransportDeviceOffset=0, size_t ipcShmForAttPoolSize=0)</td></tr>
<tr class="memdesc:a65ef0505cc8cdf7d326b70845057b7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ctor for construct local ipc <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>  <a href="#a65ef0505cc8cdf7d326b70845057b7c4">More...</a><br /></td></tr>
<tr class="separator:a65ef0505cc8cdf7d326b70845057b7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a597b30f42cb91cd7d67f9c07387f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#a82a597b30f42cb91cd7d67f9c07387f0">~Context</a> ()</td></tr>
<tr class="memdesc:a82a597b30f42cb91cd7d67f9c07387f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">dtor  <a href="#a82a597b30f42cb91cd7d67f9c07387f0">More...</a><br /></td></tr>
<tr class="separator:a82a597b30f42cb91cd7d67f9c07387f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac032504a7927c7fd46164002ee9c417a"><td class="memTemplParams" colspan="2">template&lt;typename Client &gt; </td></tr>
<tr class="memitem:ac032504a7927c7fd46164002ee9c417a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#ac032504a7927c7fd46164002ee9c417a">addToPool</a> (<a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;client, uint64_t poolThreadAffinityIn=0xfffffffffffffffful)</td></tr>
<tr class="memdesc:ac032504a7927c7fd46164002ee9c417a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a client to <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>'s pool - the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is run in pool mode  <a href="#ac032504a7927c7fd46164002ee9c417a">More...</a><br /></td></tr>
<tr class="separator:ac032504a7927c7fd46164002ee9c417a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34c8bc9a3ab6c7a09d423d28029bb98"><td class="memTemplParams" colspan="2">template&lt;typename Client , typename ... Args&gt; </td></tr>
<tr class="memitem:ad34c8bc9a3ab6c7a09d423d28029bb98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#ad34c8bc9a3ab6c7a09d423d28029bb98">addToPool</a> (<a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;client, uint64_t poolThreadAffinityIn, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ad34c8bc9a3ab6c7a09d423d28029bb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a bunch of clients to <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>'s pool - the Clients are run in pool mode  <a href="#ad34c8bc9a3ab6c7a09d423d28029bb98">More...</a><br /></td></tr>
<tr class="separator:ad34c8bc9a3ab6c7a09d423d28029bb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5523e4a9cb9357c7f44c229c29b4e930"><td class="memTemplParams" colspan="2">template&lt;typename Client , typename Client2 , typename ... Args, typename Enabled  = typename std::enable_if&lt;!std::is_integral&lt;Client2&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a5523e4a9cb9357c7f44c229c29b4e930"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#a5523e4a9cb9357c7f44c229c29b4e930">addToPool</a> (<a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;client, Client2 &amp;client2, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5523e4a9cb9357c7f44c229c29b4e930"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a bunch of clients to <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>'s pool - the Clients are run in pool mode  <a href="#a5523e4a9cb9357c7f44c229c29b4e930">More...</a><br /></td></tr>
<tr class="separator:a5523e4a9cb9357c7f44c229c29b4e930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6369f18c1f6540ff718db56d3e90fac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#ad6369f18c1f6540ff718db56d3e90fac">clientCountInPool</a> () const</td></tr>
<tr class="memdesc:ad6369f18c1f6540ff718db56d3e90fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the numebr of clients added into pool  <a href="#ad6369f18c1f6540ff718db56d3e90fac">More...</a><br /></td></tr>
<tr class="separator:ad6369f18c1f6540ff718db56d3e90fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5121642badc7e5f85d3d63a134f0a2dc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#a5121642badc7e5f85d3d63a134f0a2dc">parallelConsumerAlive</a> () const</td></tr>
<tr class="memdesc:a5121642badc7e5f85d3d63a134f0a2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">how many parallel consummers are started  <a href="#a5121642badc7e5f85d3d63a134f0a2dc">More...</a><br /></td></tr>
<tr class="separator:a5121642badc7e5f85d3d63a134f0a2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9d256caff245c03a5cd88517d6bebb"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a3b9d256caff245c03a5cd88517d6bebb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#a3b9d256caff245c03a5cd88517d6bebb">start</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3b9d256caff245c03a5cd88517d6bebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">start the context by specifying what are in it (Pool and/or direct Clients) and their paired up cpu affinities.  <a href="#a3b9d256caff245c03a5cd88517d6bebb">More...</a><br /></td></tr>
<tr class="separator:a3b9d256caff245c03a5cd88517d6bebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638db413c1f94bfc4c06aded3707c5e9"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a638db413c1f94bfc4c06aded3707c5e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#a638db413c1f94bfc4c06aded3707c5e9">registerToRun</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a638db413c1f94bfc4c06aded3707c5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">similarly to the start call for the usage and parameters except the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> thread is not started by this call and the user is expected to use <a class="el" href="structhmbdc_1_1app_1_1Context.html#a1b78fec669eea1008c778be7b6edd079" title="normally not used until you want to run your own message loop ">runOnce()</a> to manually power the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> externally  <a href="#a638db413c1f94bfc4c06aded3707c5e9">More...</a><br /></td></tr>
<tr class="separator:a638db413c1f94bfc4c06aded3707c5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06214f9b7878ea4ba0272258262953c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#ac06214f9b7878ea4ba0272258262953c">stop</a> ()</td></tr>
<tr class="memdesc:ac06214f9b7878ea4ba0272258262953c"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop the message dispatching - asynchronously  <a href="#ac06214f9b7878ea4ba0272258262953c">More...</a><br /></td></tr>
<tr class="separator:ac06214f9b7878ea4ba0272258262953c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de162ef33f552c751a024b1f4be0940"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#a6de162ef33f552c751a024b1f4be0940">join</a> ()</td></tr>
<tr class="memdesc:a6de162ef33f552c751a024b1f4be0940"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait until all threads (Pool threads too if apply) of the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> exit  <a href="#a6de162ef33f552c751a024b1f4be0940">More...</a><br /></td></tr>
<tr class="separator:a6de162ef33f552c751a024b1f4be0940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e570c8443595b5111782e257a21c92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#ac1e570c8443595b5111782e257a21c92">setSecondsBetweenPurge</a> (uint32_t s)</td></tr>
<tr class="memdesc:ac1e570c8443595b5111782e257a21c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">ipc_creator <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> runs a StcuClientPurger to purge crashed (or slow, stuck ...) Clients from the ipc transport to make the ipc trasnport healthy (avoiding buffer full). It periodically looks for things to purge. This is to set the period (default is 60 seconds).  <a href="#ac1e570c8443595b5111782e257a21c92">More...</a><br /></td></tr>
<tr class="separator:ac1e570c8443595b5111782e257a21c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b78fec669eea1008c778be7b6edd079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#a1b78fec669eea1008c778be7b6edd079">runOnce</a> (uint16_t threadSerialNumberInPool)</td></tr>
<tr class="memdesc:a1b78fec669eea1008c778be7b6edd079"><td class="mdescLeft">&#160;</td><td class="mdescRight">normally not used until you want to run your own message loop  <a href="#a1b78fec669eea1008c778be7b6edd079">More...</a><br /></td></tr>
<tr class="separator:a1b78fec669eea1008c778be7b6edd079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae531e35791fb976bc6ece2d4f679ebc1"><td class="memTemplParams" colspan="2">template&lt;typename Client &gt; </td></tr>
<tr class="memitem:ae531e35791fb976bc6ece2d4f679ebc1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#ae531e35791fb976bc6ece2d4f679ebc1">runOnce</a> (<a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;&amp;c)</td></tr>
<tr class="memdesc:ae531e35791fb976bc6ece2d4f679ebc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">normally not used until you want to run your own message loop  <a href="#ae531e35791fb976bc6ece2d4f679ebc1">More...</a><br /></td></tr>
<tr class="separator:ae531e35791fb976bc6ece2d4f679ebc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html">hmbdc::app::context_detail::ThreadCommBase&lt; MaxMessageSize, ContextProperties... &gt;</a></td></tr>
<tr class="memitem:a6e27b701264386f252400fe2d6341f69 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a6e27b701264386f252400fe2d6341f69">send</a> (M0 &amp;&amp;m0, M1 &amp;&amp;m1, Messages &amp;&amp;... msgs)</td></tr>
<tr class="memdesc:a6e27b701264386f252400fe2d6341f69 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">try send a batch of messages to the Context or attached ipc Contexts  <a href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a6e27b701264386f252400fe2d6341f69">More...</a><br /></td></tr>
<tr class="separator:a6e27b701264386f252400fe2d6341f69 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7861fcd0224c2d673a6325437a4467fb inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a7861fcd0224c2d673a6325437a4467fb">send</a> (ForwardIt begin, size_t n)</td></tr>
<tr class="memdesc:a7861fcd0224c2d673a6325437a4467fb inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a range of messages to the Context or attached ipc Contexts  <a href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a7861fcd0224c2d673a6325437a4467fb">More...</a><br /></td></tr>
<tr class="separator:a7861fcd0224c2d673a6325437a4467fb inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a647ec88806a746823c19a36d065ddd inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a9a647ec88806a746823c19a36d065ddd">send</a> (Message &amp;&amp;m)</td></tr>
<tr class="memdesc:a9a647ec88806a746823c19a36d065ddd inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a message including hasMortAttachment message to the Context or attached ipc Contexts  <a href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a9a647ec88806a746823c19a36d065ddd">More...</a><br /></td></tr>
<tr class="separator:a9a647ec88806a746823c19a36d065ddd inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cacfe72c6590582e475f14cded68a3 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a87cacfe72c6590582e475f14cded68a3">trySend</a> (M0 &amp;&amp;m0, M1 &amp;&amp;m1, Messages &amp;&amp;... msgs)</td></tr>
<tr class="memdesc:a87cacfe72c6590582e475f14cded68a3 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to send a batch of message to the Context or attached ipc Contexts  <a href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a87cacfe72c6590582e475f14cded68a3">More...</a><br /></td></tr>
<tr class="separator:a87cacfe72c6590582e475f14cded68a3 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8f5abe10947e2babd740ec439707c5 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#afa8f5abe10947e2babd740ec439707c5">trySend</a> (ForwardIt begin, size_t n)</td></tr>
<tr class="memdesc:afa8f5abe10947e2babd740ec439707c5 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">try send a range of messages to the Context or attached ipc Contexts  <a href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#afa8f5abe10947e2babd740ec439707c5">More...</a><br /></td></tr>
<tr class="separator:afa8f5abe10947e2babd740ec439707c5 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad151936a26b2e76d6154420de9d77185 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#ad151936a26b2e76d6154420de9d77185">trySend</a> (Message &amp;&amp;m)</td></tr>
<tr class="memdesc:ad151936a26b2e76d6154420de9d77185 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to send a message including hasMortAttachment message to the Context or attached ipc Contexts if it wouldn't block  <a href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#ad151936a26b2e76d6154420de9d77185">More...</a><br /></td></tr>
<tr class="separator:ad151936a26b2e76d6154420de9d77185 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e0eade3b45a7dbe0facb2fbeaa9c5e inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a81e0eade3b45a7dbe0facb2fbeaa9c5e">allocateForSend</a> (size_t n)</td></tr>
<tr class="memdesc:a81e0eade3b45a7dbe0facb2fbeaa9c5e inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">preallocate consecutive buffers so they can be send out later  <a href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a81e0eade3b45a7dbe0facb2fbeaa9c5e">More...</a><br /></td></tr>
<tr class="separator:a81e0eade3b45a7dbe0facb2fbeaa9c5e inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c1c4163fff4262115ad8b420427083 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#ae4c1c4163fff4262115ad8b420427083">commitForSend</a> (IteratorAdaptor itA)</td></tr>
<tr class="memdesc:ae4c1c4163fff4262115ad8b420427083 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">commit all the filled up buffers allocated by allocateForSend and send them out  <a href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#ae4c1c4163fff4262115ad8b420427083">More...</a><br /></td></tr>
<tr class="separator:ae4c1c4163fff4262115ad8b420427083 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2b66c5e8fd2aef04207faf79ba0425 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a4d2b66c5e8fd2aef04207faf79ba0425">sendInPlace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4d2b66c5e8fd2aef04207faf79ba0425 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a message to all Clients in the Context or attached ipc Contexts  <a href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a4d2b66c5e8fd2aef04207faf79ba0425">More...</a><br /></td></tr>
<tr class="separator:a4d2b66c5e8fd2aef04207faf79ba0425 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea1b4dba6384bb69a07822c20f350c5 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a8ea1b4dba6384bb69a07822c20f350c5">trySendInPlace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8ea1b4dba6384bb69a07822c20f350c5 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">try send a message to all Clients in the Context or attached ipc Contexts if it wouldn't block  <a href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#a8ea1b4dba6384bb69a07822c20f350c5">More...</a><br /></td></tr>
<tr class="separator:a8ea1b4dba6384bb69a07822c20f350c5 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ab84ba422763ec3232503f5a1adbd0 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memItemLeft" align="right" valign="top">Buffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#ac9ab84ba422763ec3232503f5a1adbd0">buffer</a> ()</td></tr>
<tr class="memdesc:ac9ab84ba422763ec3232503f5a1adbd0 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">accessor - mostly used internally  <a href="structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase.html#ac9ab84ba422763ec3232503f5a1adbd0">More...</a><br /></td></tr>
<tr class="separator:ac9ab84ba422763ec3232503f5a1adbd0 inherit pub_methods_structhmbdc_1_1app_1_1context__detail_1_1ThreadCommBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a147a9e55952c1c322e2dcbbca3991a17"><td class="memTemplParams" colspan="2">template&lt;typename Client &gt; </td></tr>
<tr class="memitem:a147a9e55952c1c322e2dcbbca3991a17"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhmbdc_1_1app_1_1Context.html#a147a9e55952c1c322e2dcbbca3991a17">kickOffClientThread</a> (<a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;c, uint64_t mask, uint16_t hmbdcNumber, uint16_t threadSerialNumber)</td></tr>
<tr class="separator:a147a9e55952c1c322e2dcbbca3991a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt;<br />
class hmbdc::app::Context&lt; MaxMessageSize, ContextProperties &gt;</h3>

<p>A <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> is like a media object that facilitates the communications for the Clients that it is holding. a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> can only be added to (or started within) once to a single <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>, undefined behavior otherwise. the communication model is determined by the <a class="el" href="namespacehmbdc_1_1app_1_1context__property.html">context_property</a> by default it is in the nature of broadcast fashion within local process indicating by broadcast&lt;&gt; </p>
<p>a broadcast <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> contains a thread Pool powered by a number of OS threads. a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> running in such a <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> can either run in the pool mode or a direct mode (which means the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> has its own dedicated OS thread) direct mode provides faster responses, and pool mode provides more flexibility. It is recommended that the total number of threads (pool threads + direct threads) not exceeding the number of available CPUs. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MaxMessageSize</td><td>What is the max message size if known at compile time(compile time sized); if the value can only be determined at runtime (run time sized), set this to 0. Things can still work but will lost some compile time checking advantages, see maxMessageSizeRuntime below </td></tr>
    <tr><td class="paramname">ContextProperties</td><td>see <a class="el" href="namespacehmbdc_1_1app_1_1context__property.html">context_property</a> namespace </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae217f2ebfa79ca2f5614d29a3d30d157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae217f2ebfa79ca2f5614d29a3d30d157">&#9670;&nbsp;</a></span>Context() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::<a class="el" href="structhmbdc_1_1app_1_1Context.html">Context</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>messageQueueSizePower2Num</em> = <code>MaxMessageSize?20:2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPoolClientCount</em> = <code>MaxMessageSize?128:0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxMessageSizeRuntime</em> = <code>MaxMessageSize</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ctor for construct local non-ipc <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> </p>
<p>won't compile if calling it for ipc <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageQueueSizePower2Num</td><td>value of 10 gives message queue if size of 1024 (messages, not bytes) </td></tr>
    <tr><td class="paramname">maxPoolClientCount</td><td>up to how many Clients the pool is suppose to support, only used when pool supported in the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> with broadcast property </td></tr>
    <tr><td class="paramname">maxMessageSizeRuntime</td><td>if MaxMessageSize == 0, this value is used the context can manage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65ef0505cc8cdf7d326b70845057b7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ef0505cc8cdf7d326b70845057b7c4">&#9670;&nbsp;</a></span>Context() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<div class="memtemplate">
template&lt;typename IntRvOrLv , std::enable_if_t&lt; std::is_same&lt; int, typename std::decay&lt; IntRvOrLv &gt;::type &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::<a class="el" href="structhmbdc_1_1app_1_1Context.html">Context</a> </td>
          <td>(</td>
          <td class="paramtype">IntRvOrLv &amp;&amp;&#160;</td>
          <td class="paramname"><em>ownership</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>ipcTransportName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>messageQueueSizePower2Num</em> = <code>MaxMessageSize?20:0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPoolClientCount</em> = <code>MaxMessageSize?128:0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxMessageSizeRuntime</em> = <code>MaxMessageSize</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>purgerCpuAffinityMask</em> = <code>0xfffffffffffffffful</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ipcTransportDeviceOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ipcShmForAttPoolSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ctor for construct local ipc <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> </p>
<p>won't compile if calling it for local non-ipc <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ownership</td><td>input/output flag - &lt; 0 attach only and not own it; 0 attach or create (input); <blockquote class="doxtable">
<p>0 recreate and own </p>
</blockquote>
this IPC <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> - mean ctor called on it and when exiting, remove the IPC shm file. </td></tr>
    <tr><td class="paramname">ipcTransportName</td><td>the id to identify an ipc transport that supports a group of attached together Contexts and their Clients </td></tr>
    <tr><td class="paramname">messageQueueSizePower2Num</td><td>value of 10 gives message queue if size of 1024 (messages, not bytes) </td></tr>
    <tr><td class="paramname">maxPoolClientCount</td><td>up to how many Clients the pool is suppose to support, only used when pool supported in the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> with broadcast property </td></tr>
    <tr><td class="paramname">maxMessageSizeRuntime</td><td>if MaxMessageSize == 0, this value is used </td></tr>
    <tr><td class="paramname">purgerCpuAffinityMask</td><td>which CPUs to run the low profile (sleep mostly) thread in charge of purging crashed Clients. Used only for ipc_creator Contexts. </td></tr>
    <tr><td class="paramname">ipcTransportDeviceOffset</td><td>the offset in the ipcTransport dev for the use region the context can manage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82a597b30f42cb91cd7d67f9c07387f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a597b30f42cb91cd7d67f9c07387f0">&#9670;&nbsp;</a></span>~Context()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::~<a class="el" href="structhmbdc_1_1app_1_1Context.html">Context</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dtor </p>
<p>if this <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> owns ipc transport, notify all attached processes that read from it that this tranport is dead </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac032504a7927c7fd46164002ee9c417a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac032504a7927c7fd46164002ee9c417a">&#9670;&nbsp;</a></span>addToPool() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<div class="memtemplate">
template&lt;typename Client &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::addToPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>poolThreadAffinityIn</em> = <code>0xfffffffffffffffful</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a client to <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>'s pool - the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> is run in pool mode </p>
<p>if pool is already started, the client is to get current Messages immediatly</p><ul>
<li>might miss older messages. if the pool not started yet, the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> does not get messages or other callbacks until the Pool starts. This function is threadsafe, which means you can call it anywhere in the code <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a></td><td>client type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>to be added into the Pool </td></tr>
    <tr><td class="paramname">poolThreadAffinityIn</td><td>pool is powered by a number of threads (thread in the pool is identified (by a number) in the mask starting from bit 0) it is possible to have a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> to use just some of the threads in the Pool</td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>
<p>default to use all. </p>

</div>
</div>
<a id="ad34c8bc9a3ab6c7a09d423d28029bb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34c8bc9a3ab6c7a09d423d28029bb98">&#9670;&nbsp;</a></span>addToPool() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<div class="memtemplate">
template&lt;typename Client , typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::addToPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>poolThreadAffinityIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a bunch of clients to <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>'s pool - the Clients are run in pool mode </p>
<p>if pool is already started, the client is to get current Messages immediatly</p><ul>
<li>might miss older messages. if the pool not started yet, the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> does not get messages or other callbacks until the Pool starts. This function is threadsafe, which means you can call it anywhere in the code <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a></td><td>client type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>to be added into the Pool </td></tr>
    <tr><td class="paramname">poolThreadAffinityIn</td><td>pool is powered by a number of threads (thread in the pool is identified (by a number) in the mask starting from bit 0) it is possible to have a <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> to use just some of the threads in the Pool</td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>
<p>default to use all. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>more client and poolThreadAffinityIn pairs can follow </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5523e4a9cb9357c7f44c229c29b4e930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5523e4a9cb9357c7f44c229c29b4e930">&#9670;&nbsp;</a></span>addToPool() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<div class="memtemplate">
template&lt;typename Client , typename Client2 , typename ... Args, typename Enabled  = typename std::enable_if&lt;!std::is_integral&lt;Client2&gt;::value, void&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::addToPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Client2 &amp;&#160;</td>
          <td class="paramname"><em>client2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a bunch of clients to <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>'s pool - the Clients are run in pool mode </p>
<p>the implementatiotn tells all if the pool not started yet, the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> does not get messages or other callbacks until the Pool starts. This function is threadsafe, which means you can call it anywhere in the code </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a></td><td>client type </td></tr>
    <tr><td class="paramname">Client2</td><td>client2 type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>to be added into the Pool using default poolThreadAffinity </td></tr>
    <tr><td class="paramname">client2</td><td>to be added into the Pool </td></tr>
    <tr><td class="paramname">args</td><td>more client (and/or poolThreadAffinityIn pairs can follow </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6369f18c1f6540ff718db56d3e90fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6369f18c1f6540ff718db56d3e90fac">&#9670;&nbsp;</a></span>clientCountInPool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::clientCountInPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the numebr of clients added into pool </p>
<p>the number could change since the clients could be added in another thread </p><dl class="section return"><dt>Returns</dt><dd>client count </dd></dl>

</div>
</div>
<a id="a6de162ef33f552c751a024b1f4be0940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de162ef33f552c751a024b1f4be0940">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wait until all threads (Pool threads too if apply) of the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> exit </p>
<p>blocking call </p>

</div>
</div>
<a id="a147a9e55952c1c322e2dcbbca3991a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147a9e55952c1c322e2dcbbca3991a17">&#9670;&nbsp;</a></span>kickOffClientThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<div class="memtemplate">
template&lt;typename Client &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::kickOffClientThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hmbdcNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>threadSerialNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>drain all to release sending party </p>

</div>
</div>
<a id="a5121642badc7e5f85d3d63a134f0a2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5121642badc7e5f85d3d63a134f0a2dc">&#9670;&nbsp;</a></span>parallelConsumerAlive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::parallelConsumerAlive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>how many parallel consummers are started </p>
<p>the dynamic value could change after the call returns see max_parallel_consumer <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> property </p><dl class="section return"><dt>Returns</dt><dd>how many parallel consummers are started </dd></dl>

</div>
</div>
<a id="a638db413c1f94bfc4c06aded3707c5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638db413c1f94bfc4c06aded3707c5e9">&#9670;&nbsp;</a></span>registerToRun()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::registerToRun </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>similarly to the start call for the usage and parameters except the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> thread is not started by this call and the user is expected to use <a class="el" href="structhmbdc_1_1app_1_1Context.html#a1b78fec669eea1008c778be7b6edd079" title="normally not used until you want to run your own message loop ">runOnce()</a> to manually power the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> externally </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>see start above </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>see start above </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b78fec669eea1008c778be7b6edd079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b78fec669eea1008c778be7b6edd079">&#9670;&nbsp;</a></span>runOnce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::runOnce </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>threadSerialNumberInPool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normally not used until you want to run your own message loop </p>
<p>call this function frequently to pump hmbdc message loop in its pool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadSerialNumber</td><td>starting from 0, indicate which thread in the pool is powering the loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae531e35791fb976bc6ece2d4f679ebc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae531e35791fb976bc6ece2d4f679ebc1">&#9670;&nbsp;</a></span>runOnce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<div class="memtemplate">
template&lt;typename Client &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::runOnce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmbdc_1_1app_1_1Client.html">Client</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normally not used until you want to run your own message loop </p>
<p>call this function frequently to pump hmbdc message loop for a direct mode <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadSerialNumber</td><td>indicate which thread is powering the loop </td></tr>
    <tr><td class="paramname">c</td><td>the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> did not terminate itself by throwing an exeption </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="ac1e570c8443595b5111782e257a21c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e570c8443595b5111782e257a21c92">&#9670;&nbsp;</a></span>setSecondsBetweenPurge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::setSecondsBetweenPurge </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ipc_creator <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> runs a StcuClientPurger to purge crashed (or slow, stuck ...) Clients from the ipc transport to make the ipc trasnport healthy (avoiding buffer full). It periodically looks for things to purge. This is to set the period (default is 60 seconds). </p>
<p>If some <a class="el" href="structhmbdc_1_1app_1_1Client.html" title="A Client represents a thread of execution/a task. The execution is managed by a Context. a Client object could participate in message dispatching as the receiver of specifed message types. ">Client</a> are known to take long to process messages, increase it. If you need to remove slow Clients quickly reduce it. Only effective for ipc_creator <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>seconds - if set zero, purger is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b9d256caff245c03a5cd88517d6bebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9d256caff245c03a5cd88517d6bebb">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::start </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start the context by specifying what are in it (Pool and/or direct Clients) and their paired up cpu affinities. </p>
<p>All direct mode or clients in a pool started by a single start statement are dispatched with starting from the same event (subjected to event filtering of each client). many compile time and runtime check is done, for example: won't compile if start a pool in a <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> does not support one; exception throw if the <a class="el" href="structhmbdc_1_1app_1_1Context.html" title="A Context is like a media object that facilitates the communications for the Clients that it is holdi...">Context</a> capacity is reached or try to start a second pool, etc.</p>
<p>Usage example:</p>
<div class="fragment"><div class="line"><span class="comment">// the following starts the pool powered by 3 threads that are affinitied to </span></div><div class="line"><span class="comment">// the lower 8 CPUs; client0 affinitied to 4th CPU and  client1 affinitied to 5th CPU</span></div><div class="line">ctx.start(3, 0xfful, client0, 0x8ul, client1, 0x10ul);</div><div class="line"></div><div class="line"><span class="comment">// the following starts the pool powered by 3 threads that are affinitied to </span></div><div class="line"><span class="comment">// all exisiting CPUs; client0 affinitied to a rotating CPU and </span></div><div class="line"><span class="comment">// client1 affinitied to 5th CPU</span></div><div class="line">ctx.start(3, 0, client0, 0, client1, 0x10ul);</div><div class="line"></div><div class="line"><span class="comment">// the following starts 2 direct mode Clients (client2 and client3)</span></div><div class="line">ctx.start(client2, 0x3ul, client3, 0xful);</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">typename</td><td>...Args types</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>paired up args in the form of (pool-thread-count|client, cpuAffinity)*. see examples above. If a cpuAffinity is 0, each thread's affinity rotates to one of the CPUs in the system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac06214f9b7878ea4ba0272258262953c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06214f9b7878ea4ba0272258262953c">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxMessageSize = 0, typename... ContextProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structhmbdc_1_1app_1_1Context.html">hmbdc::app::Context</a>&lt; MaxMessageSize, ContextProperties &gt;::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stop the message dispatching - asynchronously </p>
<p>asynchronously means not garanteed message dispatching stops immidiately after this non-blocking call </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hmbdc/app/<a class="el" href="Context_8hpp_source.html">Context.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
